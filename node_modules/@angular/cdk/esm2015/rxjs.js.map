{"version":3,"file":"rxjs.js","sources":["../../../src/cdk/rxjs/index.ts","../../../src/cdk/rxjs/rx-operators.ts","../../../src/cdk/rxjs/rx-chain.ts"],"sourcesContent":["/**\n * Generated bundle index. Do not edit.\n */\n\nexport {RxChain,StrictRxChain,FinallyBrand,CatchBrand,DoBrand,MapBrand,FilterBrand,ShareBrand,FirstBrand,SwitchMapBrand,StartWithBrand,DebounceTimeBrand,AuditTimeBrand,TakeUntilBrand,finallyOperatorType,catchOperatorType,doOperatorType,mapOperatorType,filterOperatorType,shareOperatorType,firstOperatorType,switchMapOperatorType,startWithOperatorType,debounceTimeOperatorType,auditTimeOperatorType,takeUntilOperatorType,finallyOperator,catchOperator,doOperator,map,filter,share,first,switchMap,startWith,debounceTime,auditTime,takeUntil} from './public_api';\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {Observable, ObservableInput} from 'rxjs/Observable';\nimport {PartialObserver} from 'rxjs/Observer';\nimport {Subscription} from 'rxjs/Subscription';\nimport {IScheduler} from 'rxjs/Scheduler';\nimport {_finally as _finallyOperator} from 'rxjs/operator/finally';\nimport {_catch as _catchOperator} from 'rxjs/operator/catch';\nimport {_do as _doOperator} from 'rxjs/operator/do';\nimport {map as mapOperator} from 'rxjs/operator/map';\nimport {filter as filterOperator} from 'rxjs/operator/filter';\nimport {share as shareOperator} from 'rxjs/operator/share';\nimport {first as firstOperator} from 'rxjs/operator/first';\nimport {switchMap as switchMapOperator} from 'rxjs/operator/switchMap';\nimport {startWith as startWithOperator} from 'rxjs/operator/startWith';\nimport {debounceTime as debounceTimeOperator} from 'rxjs/operator/debounceTime';\nimport {auditTime as auditTimeOperator} from 'rxjs/operator/auditTime';\nimport {takeUntil as takeUntilOperator} from 'rxjs/operator/takeUntil';\n\n/**\n * Represents a strongly-typed chain of RxJS operators.\n *\n * We achieve strict type enforcement on the chained operators by creating types that\n * *unambiguously* match specific rxjs operators. These unambiguous types are created by\n * intersecting a \"brand\" to the `typeof` the existing operator. The brand (a class with a private\n * member) effectively forces nominal typing for the operators. This allows typescript to understand\n * that, for example, `filter` is *`filter`* and not, say, a map of T => boolean.\n *\n * The downside to this approach is that operators must be imported in their type-coerced form\n * rather than from the normal rxjs location.\n */\nexport interface StrictRxChain<T> {\n  call<R>(operator: mapOperatorType<T, R>,\n      project: (value: T, index: number) => R, thisArg?: any): StrictRxChain<R>;\n\n  call<R>(operator: switchMapOperatorType<T, R>,\n      project: (value: T, index: number) => ObservableInput<R>): StrictRxChain<R>;\n\n  call<R>(operator: catchOperatorType<T, R>,\n      selector: (err: any, caught: Observable<T>) => ObservableInput<R>): StrictRxChain<T | R>;\n\n  call(operator: filterOperatorType<T>,\n      predicate: (value: T, index: number) => boolean, thisArg?: any): StrictRxChain<T>;\n\n  call(operator: shareOperatorType<T>): StrictRxChain<T>;\n\n  call(operator: finallyOperatorType<T>, action: () => void): StrictRxChain<T>;\n\n  call(operator: doOperatorType<T>, next: (x: T) => void, error?:\n      (e: any) => void, complete?: () => void): StrictRxChain<T>;\n\n  call(operator: doOperatorType<T>, observer: PartialObserver<T>): StrictRxChain<T>;\n\n  call(operator: firstOperatorType<T>, thisArg?: any, defaultValue?: any): StrictRxChain<T>;\n\n  call(operator: firstOperatorType<T>, predicate: (value: T) => boolean): StrictRxChain<T>;\n\n  call(operator: startWithOperatorType<T>, ...args: any[]): StrictRxChain<T>;\n\n  call(operator: debounceTimeOperatorType<T>, dueTime: number,\n      scheduler?: IScheduler): StrictRxChain<T>;\n\n  call(operator: auditTimeOperatorType<T>, duration: number,\n      scheduler?: IScheduler): StrictRxChain<T>;\n\n  call(operator: takeUntilOperatorType<T>, notifier: Observable<any>): StrictRxChain<T>;\n\n  subscribe(fn: (t: T) => void): Subscription;\n\n  result(): Observable<T>;\n}\nexport class FinallyBrand {\nprivate _; }\n\nfunction FinallyBrand_tsickle_Closure_declarations() {\n/** @type {?} */\nFinallyBrand.prototype._;\n}\n\nexport class CatchBrand {\nprivate _; }\n\nfunction CatchBrand_tsickle_Closure_declarations() {\n/** @type {?} */\nCatchBrand.prototype._;\n}\n\nexport class DoBrand {\nprivate _; }\n\nfunction DoBrand_tsickle_Closure_declarations() {\n/** @type {?} */\nDoBrand.prototype._;\n}\n\nexport class MapBrand {\nprivate _; }\n\nfunction MapBrand_tsickle_Closure_declarations() {\n/** @type {?} */\nMapBrand.prototype._;\n}\n\nexport class FilterBrand {\nprivate _; }\n\nfunction FilterBrand_tsickle_Closure_declarations() {\n/** @type {?} */\nFilterBrand.prototype._;\n}\n\nexport class ShareBrand {\nprivate _; }\n\nfunction ShareBrand_tsickle_Closure_declarations() {\n/** @type {?} */\nShareBrand.prototype._;\n}\n\nexport class FirstBrand {\nprivate _; }\n\nfunction FirstBrand_tsickle_Closure_declarations() {\n/** @type {?} */\nFirstBrand.prototype._;\n}\n\nexport class SwitchMapBrand {\nprivate _; }\n\nfunction SwitchMapBrand_tsickle_Closure_declarations() {\n/** @type {?} */\nSwitchMapBrand.prototype._;\n}\n\nexport class StartWithBrand {\nprivate _; }\n\nfunction StartWithBrand_tsickle_Closure_declarations() {\n/** @type {?} */\nStartWithBrand.prototype._;\n}\n\nexport class DebounceTimeBrand {\nprivate _; }\n\nfunction DebounceTimeBrand_tsickle_Closure_declarations() {\n/** @type {?} */\nDebounceTimeBrand.prototype._;\n}\n\nexport class AuditTimeBrand {\nprivate _; }\n\nfunction AuditTimeBrand_tsickle_Closure_declarations() {\n/** @type {?} */\nAuditTimeBrand.prototype._;\n}\n\nexport class TakeUntilBrand {\nprivate _; }\n\nfunction TakeUntilBrand_tsickle_Closure_declarations() {\n/** @type {?} */\nTakeUntilBrand.prototype._;\n}\n\n/* tslint:enable:no-unused-variable */\n\n\nexport type finallyOperatorType<T> = typeof _finallyOperator & FinallyBrand;\nexport type catchOperatorType<T, R> = typeof _catchOperator & CatchBrand;\nexport type doOperatorType<T> = typeof _doOperator & DoBrand;\nexport type mapOperatorType<T, R> = typeof mapOperator & MapBrand;\nexport type filterOperatorType<T> = typeof filterOperator & FilterBrand;\nexport type shareOperatorType<T> = typeof shareOperator & ShareBrand;\nexport type firstOperatorType<T> = typeof firstOperator & FirstBrand;\nexport type switchMapOperatorType<T, R> = typeof switchMapOperator & SwitchMapBrand;\nexport type startWithOperatorType<T> = typeof startWithOperator & StartWithBrand;\nexport type debounceTimeOperatorType<T> = typeof debounceTimeOperator & DebounceTimeBrand;\nexport type auditTimeOperatorType<T> = typeof auditTimeOperator & AuditTimeBrand;\nexport type takeUntilOperatorType<T> = typeof takeUntilOperator & TakeUntilBrand;\n\n// We add `Function` to the type intersection to make this nomically different from\n// `finallyOperatorType` while still being structurally the same. Without this, TypeScript tries to\n// reduce `typeof _finallyOperator & FinallyBrand` to `finallyOperatorType<T>` and then fails\n// because `T` isn't known.\nexport const /** @type {?} */ finallyOperator = /** @type {?} */((\n    _finallyOperator as typeof _finallyOperator & FinallyBrand & Function));\nexport const /** @type {?} */ catchOperator = /** @type {?} */(( _catchOperator as typeof _catchOperator & CatchBrand & Function));\nexport const /** @type {?} */ doOperator = /** @type {?} */(( _doOperator as typeof _doOperator & DoBrand & Function));\nexport const /** @type {?} */ map = /** @type {?} */(( mapOperator as typeof mapOperator & MapBrand & Function));\nexport const /** @type {?} */ filter = /** @type {?} */(( filterOperator as typeof filterOperator & FilterBrand & Function));\nexport const /** @type {?} */ share = /** @type {?} */(( shareOperator as typeof shareOperator & ShareBrand & Function));\nexport const /** @type {?} */ first = /** @type {?} */(( firstOperator as typeof firstOperator & FirstBrand & Function));\nexport const /** @type {?} */ switchMap = /** @type {?} */(( switchMapOperator as typeof switchMapOperator & SwitchMapBrand & Function));\nexport const /** @type {?} */ startWith = /** @type {?} */(( startWithOperator as typeof startWithOperator & StartWithBrand & Function));\nexport const /** @type {?} */ debounceTime = /** @type {?} */((\n    debounceTimeOperator as typeof debounceTimeOperator & DebounceTimeBrand & Function));\nexport const /** @type {?} */ auditTime = /** @type {?} */(( auditTimeOperator as typeof auditTimeOperator & AuditTimeBrand & Function));\nexport const /** @type {?} */ takeUntil = /** @type {?} */(( takeUntilOperator as typeof takeUntilOperator & TakeUntilBrand & Function));\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {Observable} from 'rxjs/Observable';\nimport {Subscription} from 'rxjs/Subscription';\nimport {StrictRxChain} from './rx-operators';\n/**\n * Utility class used to chain RxJS operators.\n * \n * This class is the concrete implementation, but the type used by the user when chaining\n * is StrictRxChain. The strict chain enforces types on the operators to the same level as\n * the prototype-added equivalents.\n */\nexport class RxChain<T> {\n/**\n * @param {?} _context\n */\nprivate constructor(private _context: Observable<T>) { }\n/**\n * Starts a new chain and specifies the initial `this` value.\n * @template O\n * @param {?} context Initial `this` value for the chain.\n * @return {?}\n */\nstatic from<O>(context: Observable<O>): StrictRxChain<O> {\n    return new RxChain(context);\n  }\n/**\n * Invokes an RxJS operator as a part of the chain.\n * @param {?} operator Operator to be invoked.\n * @param {...?} args Arguments to be passed to the operator.\n * @return {?}\n */\ncall(operator: Function, ...args: any[]): RxChain<any> {\n    this._context = operator.call(this._context, ...args);\n    return this;\n  }\n/**\n * Subscribes to the result of the chain.\n * @param {?} fn Callback to be invoked when the result emits a value.\n * @return {?}\n */\nsubscribe(fn: (t: T) => void): Subscription {\n    return this._context.subscribe(fn);\n  }\n/**\n * Returns the result of the chain.\n * @return {?}\n */\nresult(): Observable<T> {\n    return this._context;\n  }\n}\n\nfunction RxChain_tsickle_Closure_declarations() {\n/** @type {?} */\nRxChain.prototype._context;\n}\n\n"],"names":["takeUntil","takeUntilOperator","auditTime","auditTimeOperator","debounceTime","debounceTimeOperator","startWith","startWithOperator","switchMap","switchMapOperator","first","firstOperator","share","shareOperator","filter","filterOperator","map","mapOperator","_doOperator","_catchOperator","_finallyOperator"],"mappings":";;;;;;;;;;;;;;;;;;;;AEYA;;;;;;;AAOA,AAAA,MAAA,OAAA,CAAA;;;;IAIA,WAAA,CAH8B,QAAuB,EAGrD;QAH8B,IAA9B,CAAA,QAA8B,GAAA,QAAA,CAAuB;KAAC;;;;;;;IAUtD,OAJG,IAAA,CAAA,OAAA,EAIH;QACI,OAJO,IAAI,OAAA,CAAQ,OAAC,CAAO,CAAC;KAK7B;;;;;;;IAOH,IAJG,CAAA,QAAA,EAAA,GAAA,IAAA,EAIH;QACI,IAAI,CAJC,QAAC,GAAU,QAAA,CAAS,IAAC,CAAI,IAAC,CAAI,QAAC,EAAS,GAAA,IAAI,CAAI,CAAC;QAKtD,OAJO,IAAA,CAAK;KAKb;;;;;;IAMH,SAJG,CAAA,EAAA,EAIH;QACI,OAJO,IAAA,CAAK,QAAC,CAAQ,SAAC,CAAS,EAAC,CAAE,CAAC;KAKpC;;;;;IAKH,MAJG,GAIH;QACI,OAJO,IAAA,CAAK,QAAC,CAAQ;KAKtB;CACF,AAED,AAGC;;ADeD,MAAA,YAAA,CAAA;CACuC;AAEvC,AAKA,AAAA,MAAA,UAAA,CAAA;CANqC;AASrC,AAKA,AAAA,MAAA,OAAA,CAAA;CAbkC;AAgBlC,AAKA,AAAA,MAAA,QAAA,CAAA;CApBmC;AAuBnC,AAKA,AAAA,MAAA,WAAA,CAAA;CA3BsC;AA8BtC,AAKA,AAAA,MAAA,UAAA,CAAA;CAlCqC;AAqCrC,AAKA,AAAA,MAAA,UAAA,CAAA;CAzCqC;AA4CrC,AAKA,AAAA,MAAA,cAAA,CAAA;CAhDyC;AAmDzC,AAKA,AAAA,MAAA,cAAA,CAAA;CAvDyC;AA0DzC,AAKA,AAAA,MAAA,iBAAA,CAAA;CA9D4C;AAiE5C,AAKA,AAAA,MAAA,cAAA,CAAA;CArEyC;AAwEzC,AAKA,AAAA,MAAA,cAAA,CAAA;CA5EyC;AA+EzC,AAqBA;;;;AAIA,AAnFO,MAAM,eAAA,IAoFToB,QAnF6D,CAAA,CAAS;AAoF1E,AAnFO,MAAM,aAAA,IAAgBD,MAAuD,CAAA,CAAS;AAoF7F,AAnFO,MAAM,UAAA,IAAaD,GAA8C,CAAA,CAAS;AAoFjF,AAnFO,MAAMF,KAAA,IAAMC,GAA+C,CAAA,CAAS;AAoF3E,AAnFO,MAAMH,QAAA,IAASC,MAAwD,CAAA,CAAS;AAoFvF,AAnFO,MAAMH,OAAA,IAAQC,KAAqD,CAAA,CAAS;AAoFnF,AAnFO,MAAMH,OAAA,IAAQC,KAAqD,CAAA,CAAS;AAoFnF,AAnFO,MAAMH,WAAA,IAAYC,SAAiE,CAAA,CAAS;AAoFnG,AAnFO,MAAMH,WAAA,IAAYC,SAAiE,CAAA,CAAS;AAoFnG,AAnFO,MAAMH,cAAA,IAoFTC,YAnF0E,CAAA,CAAS;AAoFvF,AAnFO,MAAMH,WAAA,IAAYC,SAAiE,CAAA,CAAS;AAoFnG,AAnFO,MAAMH,WAAA,IAAYC,SAAiE,CAAA,CAAS;;AD5HnG;;GAEG,AAEH,AAA8iB;;"}