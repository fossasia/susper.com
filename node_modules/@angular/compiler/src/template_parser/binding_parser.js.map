{"version":3,"file":"binding_parser.js","sourceRoot":"","sources":["../../../../../modules/@angular/compiler/src/template_parser/binding_parser.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;;;;;;OAEI,EAAC,eAAe,EAAC,MAAM,eAAe;OAGtC,EAA6B,SAAS,EAAe,mBAAmB,EAAkB,MAAM,0BAA0B;OAE1H,EAAC,SAAS,EAAC,MAAM,gBAAgB;OAEjC,EAAC,cAAc,EAAC,MAAM,mBAAmB;OACzC,EAAC,UAAU,EAAE,eAAe,EAAE,eAAe,EAAC,MAAM,eAAe;OAEnE,EAAC,WAAW,EAAC,MAAM,aAAa;OAChC,EAAC,YAAY,EAAE,aAAa,EAAC,MAAM,SAAS;OAE5C,EAAC,uBAAuB,EAAE,aAAa,EAAE,mBAAmB,EAAE,WAAW,EAAC,MAAM,gBAAgB;AAEvG,IAAM,gBAAgB,CAAC,wBAAwB,GAAG,GAAG,CAAC;AACtD,IAAM,gBAAgB,CAAC,gBAAgB,GAAG,MAAM,CAAC;AACjD,IAAM,gBAAgB,CAAC,YAAY,GAAG,OAAO,CAAC;AAC9C,IAAM,gBAAgB,CAAC,YAAY,GAAG,OAAO,CAAC;AAE9C,IAAM,gBAAgB,CAAC,mBAAmB,GAAG,UAAU,CAAC;AAExD,OAAO,IAAI,iBAAiB,GAAQ,EAAE,CAAC;AACvC,iBAAiB,CAAC,OAAO,GAAG,CAAC,CAAC;AAC9B,iBAAiB,CAAC,YAAY,GAAG,CAAC,CAAC;AACnC,iBAAiB,CAAC,SAAS,GAAG,CAAC,CAAC;AAChC,iBAAiB,CAAC,iBAAiB,CAAC,OAAO,CAAC,GAAG,SAAS,CAAC;AACzD,iBAAiB,CAAC,iBAAiB,CAAC,YAAY,CAAC,GAAG,cAAc,CAAC;AACnE,iBAAiB,CAAC,iBAAiB,CAAC,SAAS,CAAC,GAAG,WAAW,CAAC;AAE7D;;GAEG;AACH;IACA;;;;;OAKG;IACH,uBACO,IAAY,EACZ,UAAyB,EACzB,IAAuB,EACvB,UAA2B;QAH3B,SAAI,GAAJ,IAAI,CAAQ;QACZ,eAAU,GAAV,UAAU,CAAe;QACzB,SAAI,GAAJ,IAAI,CAAmB;QACvB,eAAU,GAAV,UAAU,CAAiB;IAAG,CAAC;IAItC,sBAAI,oCAAS;QAHb;;WAEG;aACH,cAAkB,MAAM,CAAC,IAAI,CAAC,IAAI,KAAK,iBAAiB,CAAC,YAAY,CAAC,CAAC,CAAC;;;OAAA;IAIxE,sBAAI,sCAAW;QAHf;;WAEG;aACH,cAAoB,MAAM,CAAC,IAAI,CAAC,IAAI,KAAK,iBAAiB,CAAC,SAAS,CAAC,CAAC,CAAC;;;OAAA;IACvE,oBAAC;AAAD,CAAC,AApBD,IAoBC;AAED;IACC,gBAAgB;IACjB,aAAa,CAAC,SAAS,CAAC,IAAI,CAAC;IAC5B,gBAAgB;IACjB,aAAa,CAAC,SAAS,CAAC,UAAU,CAAC;IAClC,gBAAgB;IACjB,aAAa,CAAC,SAAS,CAAC,IAAI,CAAC;IAC5B,gBAAgB;IACjB,aAAa,CAAC,SAAS,CAAC,UAAU,CAAC;AACnC,CAAC;AAED;;GAEG;AACH;IAEA;;;;;;OAMG;IACH,uBACQ,WAAmB,EACnB,oBAAyC,EACzC,eAAsC,EAAE,KAA2B,EACnE,aAA2B;QAbnC,iBAkdC;QAxcO,gBAAW,GAAX,WAAW,CAAQ;QACnB,yBAAoB,GAApB,oBAAoB,CAAqB;QACzC,oBAAe,GAAf,eAAe,CAAuB;QACtC,kBAAa,GAAb,aAAa,CAAc;QAZjC,gBAAW,GAAoC,IAAI,GAAG,EAAE,CAAC;QAavD,KAAK,CAAC,OAAO,CAAC,UAAA,IAAI,IAAI,OAAA,KAAI,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,EAArC,CAAqC,CAAC,CAAC;IAC/D,CAAC;IACH;;;;OAIG;IACH,uDAA+B,GAA/B,UAAgC,OAAgC,EAAE,UAA2B;QAA7F,iBAgBG;QAdC,EAAE,CAAC,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC,CAAC;YAC3B,IAAM,gBAAgB,CAAC,YAAU,GAAoB,EAAE,CAAC;YACxD,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC,OAAO,CAAC,UAAA,QAAQ;gBAClD,IAAM,gBAAgB,CAAC,UAAU,GAAG,OAAO,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;gBACrE,EAAE,CAAC,CAAC,OAAO,UAAU,KAAK,QAAQ,CAAC,CAAC,CAAC;oBACnC,KAAI,CAAC,oBAAoB,CAAC,QAAQ,EAAE,UAAU,EAAE,IAAI,EAAE,UAAU,EAAE,EAAE,EAAE,YAAU,CAAC,CAAC;gBACpF,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,KAAI,CAAC,YAAY,CACb,0CAAuC,QAAQ,qEAA8D,UAAU,YAAM,OAAO,UAAU,MAAG,EACjJ,UAAU,CAAC,CAAC;gBAClB,CAAC;YACH,CAAC,CAAC,CAAC;YACH,MAAM,CAAC,YAAU,CAAC,GAAG,CAAC,UAAC,IAAI,IAAK,OAAA,KAAI,CAAC,wBAAwB,CAAC,OAAO,CAAC,QAAQ,EAAE,IAAI,CAAC,EAArD,CAAqD,CAAC,CAAC;QACzF,CAAC;IACH,CAAC;IACH;;;;OAIG;IACH,oDAA4B,GAA5B,UAA6B,OAAgC,EAAE,UAA2B;QAA1F,iBAgBG;QAdC,EAAE,CAAC,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC,CAAC;YAC1B,IAAM,gBAAgB,CAAC,iBAAe,GAAoB,EAAE,CAAC;YAC7D,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC,OAAO,CAAC,UAAA,QAAQ;gBACjD,IAAM,gBAAgB,CAAC,UAAU,GAAG,OAAO,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;gBACpE,EAAE,CAAC,CAAC,OAAO,UAAU,KAAK,QAAQ,CAAC,CAAC,CAAC;oBACnC,KAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,UAAU,EAAE,UAAU,EAAE,EAAE,EAAE,iBAAe,CAAC,CAAC;gBACzE,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,KAAI,CAAC,YAAY,CACb,kCAA+B,QAAQ,qEAA8D,UAAU,YAAM,OAAO,UAAU,MAAG,EACzI,UAAU,CAAC,CAAC;gBAClB,CAAC;YACH,CAAC,CAAC,CAAC;YACH,MAAM,CAAC,iBAAe,CAAC;QACzB,CAAC;IACH,CAAC;IACH;;;;OAIG;IACH,0CAAkB,GAAlB,UAAmB,KAAa,EAAE,UAA2B;QACzD,IAAM,gBAAgB,CAAC,UAAU,GAAG,UAAU,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC;QAEhE,IAAI,CAAC;YACH,IAAM,gBAAgB,CAAC,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,kBAAkB,CAAC,KAAK,EAAE,UAAU,EAAE,IAAI,CAAC,oBAAoB,CAAC,CAAC;YAC/G,EAAE,CAAC,CAAC,GAAG,CAAC;gBAAC,IAAI,CAAC,6BAA6B,CAAC,GAAG,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;YACpE,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,UAAU,CAAC,CAAC;YAClC,MAAM,CAAC,GAAG,CAAC;QACb,CAAE;QAAA,KAAK,CAAC,CAAkB,CAAC,CAAC,CAAC,CAAC;YAC5B,IAAI,CAAC,YAAY,CAAC,KAAG,CAAG,EAAE,UAAU,CAAC,CAAC;YACtC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,oBAAoB,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC;QACpE,CAAC;IACH,CAAC;IACH;;;;;;;;;OASG;IACH,kDAA0B,GAA1B,UACM,IAAY,EAAE,WAAmB,EAAE,KAAa,EAAE,UAA2B,EAC7E,oBAAgC,EAAE,WAA4B,EAAE,UAAyB;QAC3F,IAAM,gBAAgB,CAAC,QAAQ,GAAG,IAAI,CAAC,sBAAsB,CAAC,WAAW,EAAE,KAAK,EAAE,UAAU,CAAC,CAAC;QAC9F,GAAG,CAAC,CAAC,IAAI,gBAAgB,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAC1D,IAAM,gBAAgB,CAAC,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;YAC7C,EAAE,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC;gBACrB,UAAU,CAAC,IAAI,CAAC,IAAI,WAAW,CAAC,OAAO,CAAC,GAAG,EAAE,OAAO,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC,CAAC;YAC1E,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,SAAS,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;gBACzC,IAAI,CAAC,iBAAiB,CAClB,OAAO,CAAC,GAAG,EAAE,OAAO,CAAC,UAAU,EAAE,UAAU,EAAE,oBAAoB,EAAE,WAAW,CAAC,CAAC;YACtF,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,oBAAoB,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,CAAC;gBAC7C,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,GAAG,EAAE,IAAI,EAAE,UAAU,EAAE,oBAAoB,EAAE,WAAW,CAAC,CAAC;YAC1F,CAAC;QACH,CAAC;IACH,CAAC;IACH;;;;;OAKG;IACK,8CAAsB,GAA9B,UAA+B,WAAmB,EAAE,KAAa,EAAE,UAA2B;QAA9F,iBAmBG;QAjBC,IAAM,gBAAgB,CAAC,UAAU,GAAG,UAAU,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC;QAEhE,IAAI,CAAC;YACH,IAAM,gBAAgB,CAAC,cAAc,GAAG,IAAI,CAAC,WAAW,CAAC,qBAAqB,CAAC,WAAW,EAAE,KAAK,EAAE,UAAU,CAAC,CAAC;YAC/G,IAAI,CAAC,6BAA6B,CAAC,cAAc,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;YACtE,cAAc,CAAC,gBAAgB,CAAC,OAAO,CAAC,UAAC,OAAO;gBAC9C,EAAE,CAAC,CAAC,SAAS,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;oBAClC,KAAI,CAAC,WAAW,CAAC,OAAO,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;gBACnD,CAAC;YACH,CAAC,CAAC,CAAC;YACH,cAAc,CAAC,QAAQ,CAAC,OAAO,CAC3B,UAAC,OAAO,IAAO,KAAI,CAAC,YAAY,CAAC,OAAO,EAAE,UAAU,EAAE,eAAe,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACvF,MAAM,CAAC,cAAc,CAAC,gBAAgB,CAAC;QACzC,CAAE;QAAA,KAAK,CAAC,CAAkB,CAAC,CAAC,CAAC,CAAC;YAC5B,IAAI,CAAC,YAAY,CAAC,KAAG,CAAG,EAAE,UAAU,CAAC,CAAC;YACtC,MAAM,CAAC,EAAE,CAAC;QACZ,CAAC;IACH,CAAC;IACH;;;;;;;OAOG;IACH,wCAAgB,GAAhB,UACM,IAAY,EAAE,KAAa,EAAE,UAA2B,EAAE,oBAAgC,EAC1F,WAA4B;QAC9B,EAAE,CAAC,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAC5B,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;YACzB,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;gBACV,IAAI,CAAC,YAAY,CACb,0FAAwF;oBACpF,yGAAuG,EAC3G,UAAU,EAAE,eAAe,CAAC,KAAK,CAAC,CAAC;YACzC,CAAC;YACD,IAAI,CAAC,eAAe,CAAC,IAAI,EAAE,KAAK,EAAE,UAAU,EAAE,oBAAoB,EAAE,WAAW,CAAC,CAAC;QACnF,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,WAAW,CAAC,IAAI,CAAC,IAAI,aAAa,CAC9B,IAAI,EAAE,IAAI,CAAC,WAAW,CAAC,oBAAoB,CAAC,KAAK,EAAE,EAAE,CAAC,EAAE,iBAAiB,CAAC,YAAY,EACtF,UAAU,CAAC,CAAC,CAAC;QACnB,CAAC;IACH,CAAC;IACH;;;;;;;;OAQG;IACH,4CAAoB,GAApB,UACM,IAAY,EAAE,UAAkB,EAAE,MAAe,EAAE,UAA2B,EAC9E,oBAAgC,EAAE,WAA4B;QAChE,IAAI,gBAAgB,CAAC,eAAe,GAAG,KAAK,CAAC;QAC7C,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,mBAAmB,CAAC,CAAC,CAAC,CAAC;YACzC,eAAe,GAAG,IAAI,CAAC;YACvB,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,mBAAmB,CAAC,MAAM,CAAC,CAAC;QACpD,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACnC,eAAe,GAAG,IAAI,CAAC;YACvB,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;QAC3B,CAAC;QAED,EAAE,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC;YACpB,IAAI,CAAC,eAAe,CAAC,IAAI,EAAE,UAAU,EAAE,UAAU,EAAE,oBAAoB,EAAE,WAAW,CAAC,CAAC;QACxF,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,IAAI,CAAC,iBAAiB,CAClB,IAAI,EAAE,IAAI,CAAC,aAAa,CAAC,UAAU,EAAE,MAAM,EAAE,UAAU,CAAC,EAAE,UAAU,EACpE,oBAAoB,EAAE,WAAW,CAAC,CAAC;QACzC,CAAC;IACH,CAAC;IACH;;;;;;;OAOG;IACH,kDAA0B,GAA1B,UACM,IAAY,EAAE,KAAa,EAAE,UAA2B,EAAE,oBAAgC,EAC1F,WAA4B;QAC9B,IAAM,gBAAgB,CAAC,IAAI,GAAG,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;QACzE,EAAE,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACpB,IAAI,CAAC,iBAAiB,CAAC,IAAI,EAAE,IAAI,EAAE,UAAU,EAAE,oBAAoB,EAAE,WAAW,CAAC,CAAC;YAClF,MAAM,CAAC,IAAI,CAAC;QACd,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACf,CAAC;IACH;;;;;;;OAOG;IACK,yCAAiB,GAAzB,UACM,IAAY,EAAE,GAAkB,EAAE,UAA2B,EAC7D,oBAAgC,EAAE,WAA4B;QAChE,oBAAoB,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC;QAC9C,WAAW,CAAC,IAAI,CAAC,IAAI,aAAa,CAAC,IAAI,EAAE,GAAG,EAAE,iBAAiB,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC,CAAC;IACxF,CAAC;IACH;;;;;;;OAOG;IACK,uCAAe,GAAvB,UACM,IAAY,EAAE,UAAkB,EAAE,UAA2B,EAC7D,oBAAgC,EAAE,WAA4B;QAChE,oEAAoE;QACpE,oEAAoE;QACpE,0EAA0E;QAC1E,IAAM,gBAAgB,CAAC,GAAG,GAAG,IAAI,CAAC,aAAa,CAAC,UAAU,IAAI,MAAM,EAAE,KAAK,EAAE,UAAU,CAAC,CAAC;QACzF,oBAAoB,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC;QAC9C,WAAW,CAAC,IAAI,CAAC,IAAI,aAAa,CAAC,IAAI,EAAE,GAAG,EAAE,iBAAiB,CAAC,SAAS,EAAE,UAAU,CAAC,CAAC,CAAC;IAC1F,CAAC;IACH;;;;;OAKG;IACK,qCAAa,GAArB,UAAsB,KAAa,EAAE,aAAsB,EAAE,UAA2B;QAEpF,IAAM,gBAAgB,CAAC,UAAU,GAAG,UAAU,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC;QAEhE,IAAI,CAAC;YACH,IAAM,gBAAgB,CAAC,GAAG,GAAG,aAAa;gBACtC,IAAI,CAAC,WAAW,CAAC,kBAAkB,CAAC,KAAK,EAAE,UAAU,EAAE,IAAI,CAAC,oBAAoB,CAAC;gBACjF,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC,KAAK,EAAE,UAAU,EAAE,IAAI,CAAC,oBAAoB,CAAC,CAAC;YAChF,EAAE,CAAC,CAAC,GAAG,CAAC;gBAAC,IAAI,CAAC,6BAA6B,CAAC,GAAG,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;YACpE,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,UAAU,CAAC,CAAC;YAClC,MAAM,CAAC,GAAG,CAAC;QACb,CAAE;QAAA,KAAK,CAAC,CAAkB,CAAC,CAAC,CAAC,CAAC;YAC5B,IAAI,CAAC,YAAY,CAAC,KAAG,CAAG,EAAE,UAAU,CAAC,CAAC;YACtC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,oBAAoB,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC;QACpE,CAAC;IACH,CAAC;IACH;;;;OAIG;IACH,gDAAwB,GAAxB,UAAyB,eAAuB,EAAE,SAAwB;QAEtE,EAAE,CAAC,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC,CAAC;YAC1B,MAAM,CAAC,IAAI,uBAAuB,CAC9B,SAAS,CAAC,IAAI,EAAE,mBAAmB,CAAC,SAAS,EAAE,eAAe,CAAC,IAAI,EAAE,KAAK,EAC1E,SAAS,CAAC,UAAU,EAAE,IAAI,EAAE,SAAS,CAAC,UAAU,CAAC,CAAC;QACxD,CAAC;QAED,IAAI,gBAAgB,CAAC,IAAI,GAAW,IAAI,CAAC;QACzC,IAAI,gBAAgB,CAAC,WAAgC,CAAC;QACtD,IAAI,gBAAgB,CAAC,iBAAiB,GAAW,IAAI,CAAC;QACtD,IAAM,gBAAgB,CAAC,KAAK,GAAG,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,wBAAwB,CAAC,CAAC;QAC9E,IAAI,gBAAgB,CAAC,gBAAmC,CAAC;QAEzD,4DAA4D;QAC5D,EAAE,CAAC,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YACrB,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,gBAAgB,CAAC,CAAC,CAAC;gBACjC,iBAAiB,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;gBAC7B,IAAI,CAAC,gCAAgC,CAAC,iBAAiB,EAAE,SAAS,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;gBACrF,gBAAgB,GAAG,4BAA4B,CAC3C,IAAI,CAAC,eAAe,EAAE,eAAe,EAAE,iBAAiB,EAAE,IAAI,CAAC,CAAC;gBAEpE,IAAM,gBAAgB,CAAC,cAAc,GAAG,iBAAiB,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;gBACvE,EAAE,CAAC,CAAC,cAAc,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;oBACxB,IAAM,gBAAgB,CAAC,EAAE,GAAG,iBAAiB,CAAC,SAAS,CAAC,CAAC,EAAE,cAAc,CAAC,CAAC;oBAC3E,IAAM,gBAAgB,CAAC,MAAI,GAAG,iBAAiB,CAAC,SAAS,CAAC,cAAc,GAAG,CAAC,CAAC,CAAC;oBAC9E,iBAAiB,GAAG,cAAc,CAAC,EAAE,EAAE,MAAI,CAAC,CAAC;gBAC/C,CAAC;gBAED,WAAW,GAAG,mBAAmB,CAAC,SAAS,CAAC;YAC9C,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,YAAY,CAAC,CAAC,CAAC;gBACpC,iBAAiB,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;gBAC7B,WAAW,GAAG,mBAAmB,CAAC,KAAK,CAAC;gBACxC,gBAAgB,GAAG,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;YAC5C,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,YAAY,CAAC,CAAC,CAAC;gBACpC,IAAI,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;gBAC1C,iBAAiB,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;gBAC7B,WAAW,GAAG,mBAAmB,CAAC,KAAK,CAAC;gBACxC,gBAAgB,GAAG,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;YAC7C,CAAC;QACH,CAAC;QAED,oDAAoD;QACpD,EAAE,CAAC,CAAC,iBAAiB,KAAK,IAAI,CAAC,CAAC,CAAC;YAC/B,iBAAiB,GAAG,IAAI,CAAC,eAAe,CAAC,iBAAiB,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;YAC3E,gBAAgB,GAAG,4BAA4B,CAC3C,IAAI,CAAC,eAAe,EAAE,eAAe,EAAE,iBAAiB,EAAE,KAAK,CAAC,CAAC;YACrE,WAAW,GAAG,mBAAmB,CAAC,QAAQ,CAAC;YAC3C,IAAI,CAAC,gCAAgC,CAAC,iBAAiB,EAAE,SAAS,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;QACxF,CAAC;QAED,MAAM,CAAC,IAAI,uBAAuB,CAC9B,iBAAiB,EAAE,WAAW,EAAE,gBAAgB,CAAC,MAAM,KAAK,CAAC,GAAG,gBAAgB,CAAC,CAAC,CAAC,GAAG,IAAI,EAC1F,gBAAgB,CAAC,MAAM,GAAG,CAAC,EAAE,SAAS,CAAC,UAAU,EAAE,IAAI,EAAE,SAAS,CAAC,UAAU,CAAC,CAAC;IACrF,CAAC;IACH;;;;;;;OAOG;IACH,kCAAU,GAAV,UACM,IAAY,EAAE,UAAkB,EAAE,UAA2B,EAC7D,oBAAgC,EAAE,YAA6B;QACjE,EAAE,CAAC,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAC5B,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;YACtB,IAAI,CAAC,oBAAoB,CAAC,IAAI,EAAE,UAAU,EAAE,UAAU,EAAE,YAAY,CAAC,CAAC;QACxE,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,UAAU,EAAE,UAAU,EAAE,oBAAoB,EAAE,YAAY,CAAC,CAAC;QACrF,CAAC;IACH,CAAC;IACH;;;;;;OAMG;IACK,4CAAoB,GAA5B,UACM,IAAY,EAAE,UAAkB,EAAE,UAA2B,EAC7D,YAA6B;QAC/B,IAAM,gBAAgB,CAAC,OAAO,GAAG,aAAa,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,CAAC;QACjE,IAAM,gBAAgB,CAAC,SAAS,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;QAC9C,IAAM,gBAAgB,CAAC,KAAK,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC;QACxD,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACV,MAAM,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;gBACd,KAAK,OAAO,CAAC;gBACb,KAAK,MAAM;oBACT,IAAM,gBAAgB,CAAC,GAAG,GAAG,IAAI,CAAC,YAAY,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;oBACvE,YAAY,CAAC,IAAI,CAAC,IAAI,aAAa,CAAC,SAAS,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,EAAE,UAAU,CAAC,CAAC,CAAC;oBAC9E,KAAK,CAAC;gBAER;oBACE,IAAI,CAAC,YAAY,CACb,iDAA8C,KAAK,kBAAW,SAAS,4CAAwC,EAC/G,UAAU,CAAC,CAAC;oBAChB,KAAK,CAAC;YACV,CAAC;QACH,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,IAAI,CAAC,YAAY,CACb,0CAAwC,SAAS,8EAA2E,EAC5H,UAAU,CAAC,CAAC;QAClB,CAAC;IACH,CAAC;IACH;;;;;;;OAOG;IACK,mCAAW,GAAnB,UACM,IAAY,EAAE,UAAkB,EAAE,UAA2B,EAC7D,oBAAgC,EAAE,YAA6B;QACjE,mCAAmC;QACnC,IAAA,qCAA4D,EAArD,cAAM,EAAE,iBAAS,CAAqC;QAC7D,IAAM,gBAAgB,CAAC,GAAG,GAAG,IAAI,CAAC,YAAY,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;QACvE,oBAAoB,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC;QAC9C,YAAY,CAAC,IAAI,CAAC,IAAI,aAAa,CAAC,SAAS,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE,UAAU,CAAC,CAAC,CAAC;QAC/E,mDAAmD;QACnD,oDAAoD;IACtD,CAAC;IACH;;;;OAIG;IACK,oCAAY,GAApB,UAAqB,KAAa,EAAE,UAA2B;QAC3D,IAAM,gBAAgB,CAAC,UAAU,GAAG,UAAU,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC;QAEhE,IAAI,CAAC;YACH,IAAM,gBAAgB,CAAC,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,KAAK,EAAE,UAAU,EAAE,IAAI,CAAC,oBAAoB,CAAC,CAAC;YACxG,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gBACR,IAAI,CAAC,6BAA6B,CAAC,GAAG,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;YAC7D,CAAC;YACD,EAAE,CAAC,CAAC,CAAC,GAAG,IAAI,GAAG,CAAC,GAAG,YAAY,SAAS,CAAC,CAAC,CAAC;gBACzC,IAAI,CAAC,YAAY,CAAC,mCAAmC,EAAE,UAAU,CAAC,CAAC;gBACnE,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,oBAAoB,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC;YACpE,CAAC;YACD,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,UAAU,CAAC,CAAC;YAClC,MAAM,CAAC,GAAG,CAAC;QACb,CAAE;QAAA,KAAK,CAAC,CAAkB,CAAC,CAAC,CAAC,CAAC;YAC5B,IAAI,CAAC,YAAY,CAAC,KAAG,CAAG,EAAE,UAAU,CAAC,CAAC;YACtC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,oBAAoB,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC;QACpE,CAAC;IACH,CAAC;IACH;;;;;OAKG;IACK,oCAAY,GAApB,UACM,OAAe,EAAE,UAA2B,EAC5C,KAA8C;QAA9C,qBAA8C,GAA9C,QAAyB,eAAe,CAAC,KAAK;QAChD,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,UAAU,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;IACtE,CAAC;IACH;;;;OAIG;IACK,qDAA6B,GAArC,UAAsC,MAAqB,EAAE,UAA2B;QACpF,GAAG,CAAC,CAAiC,UAAM,EAAN,iBAAM,EAAN,oBAAM,EAAN,IAAM,CAAC;YAAvC,IAAuB,KAAK,eAAA;YAC/B,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC;SAC9C;IACH,CAAC;IACH;;;;OAIG;IACK,mCAAW,GAAnB,UAAoB,GAAkB,EAAE,UAA2B;QAAnE,iBAaG;QAZC,EAAE,CAAC,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YACnB,IAAM,gBAAgB,CAAC,SAAS,GAAG,IAAI,aAAa,EAAE,CAAC;YACvD,GAAG,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;YACrB,SAAS,CAAC,KAAK,CAAC,OAAO,CAAC,UAAC,GAAG,EAAE,QAAQ;gBACpC,EAAE,CAAC,CAAC,CAAC,KAAI,CAAC,WAAW,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;oBACpC,KAAI,CAAC,YAAY,CACb,eAAa,QAAQ,yBAAsB,EAC3C,IAAI,eAAe,CACf,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;gBAC3F,CAAC;YACH,CAAC,CAAC,CAAC;QACL,CAAC;IACH,CAAC;IACH;;;;;OAKG;IACK,wDAAgC,GAAxC,UACM,QAAgB,EAAE,UAA2B,EAAE,MAAe;QAChE,IAAM,gBAAgB,CAAC,MAAM,GAAG,MAAM,GAAG,IAAI,CAAC,eAAe,CAAC,iBAAiB,CAAC,QAAQ,CAAC;YACjE,IAAI,CAAC,eAAe,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;QACxE,EAAE,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;YACjB,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,GAAG,EAAE,UAAU,EAAE,eAAe,CAAC,KAAK,CAAC,CAAC;QACnE,CAAC;IACH,CAAC;IACH,oBAAC;AAAD,CAAC,AAldD,IAkdC;AAED;IACC,gBAAgB;IACjB,aAAa,CAAC,SAAS,CAAC,WAAW,CAAC;IACnC,gBAAgB;IACjB,aAAa,CAAC,SAAS,CAAC,WAAW,CAAC;IACnC,gBAAgB;IACjB,aAAa,CAAC,SAAS,CAAC,oBAAoB,CAAC;IAC5C,gBAAgB;IACjB,aAAa,CAAC,SAAS,CAAC,eAAe,CAAC;IACvC,gBAAgB;IACjB,aAAa,CAAC,SAAS,CAAC,aAAa,CAAC;AACtC,CAAC;AAGD;IAAmC,iCAAmB;IAAtD;QAAmC,8BAAmB;QACpD,UAAK,GAAG,IAAI,GAAG,EAAuB,CAAC;IAYzC,CAAC;IAXD;;;;OAIG;IACH,iCAAS,GAAT,UAAU,GAAgB,EAAE,OAAY;QACpC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;QAC9B,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QACpB,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QACjC,MAAM,CAAC,IAAI,CAAC;IACd,CAAC;IACH,oBAAC;AAAD,CAAC,AAbD,CAAmC,mBAAmB,GAarD;AAED;IACC,gBAAgB;IACjB,aAAa,CAAC,SAAS,CAAC,KAAK,CAAC;AAC9B,CAAC;AAED;;;GAGG;AACH,2BAA2B,IAAY;IACrC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,GAAG,CAAC;AACxB,CAAC;AACD;;;;;;GAMG;AACH,6CACI,QAA+B,EAAE,QAAgB,EAAE,QAAgB,EACnE,WAAoB;IACtB,IAAM,gBAAgB,CAAC,IAAI,GAAsB,EAAE,CAAC;IACpD,WAAW,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,UAAC,QAAQ;QAC3C,IAAM,gBAAgB,CAAC,YAAY,GAAG,QAAQ,CAAC,OAAO,GAAG,CAAC,QAAQ,CAAC,OAAO,CAAC,GAAG,QAAQ,CAAC,oBAAoB,EAAE,CAAC;QAC9G,IAAM,gBAAgB,CAAC,eAAe,GAClC,IAAI,GAAG,CAAC,QAAQ,CAAC,YAAY,CAAC,MAAM,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,iBAAiB,EAAE,EAA5B,CAA4B,CAAC;aACjE,GAAG,CAAC,UAAC,QAAQ,IAAK,OAAA,QAAQ,CAAC,OAAO,EAAhB,CAAgB,CAAC,CAAC,CAAC;QACtD,IAAM,gBAAgB,CAAC,oBAAoB,GACvC,YAAY,CAAC,MAAM,CAAC,UAAA,WAAW,IAAI,OAAA,CAAC,eAAe,CAAC,GAAG,CAAC,WAAW,CAAC,EAAjC,CAAiC,CAAC,CAAC;QAE1E,IAAI,CAAC,IAAI,OAAT,IAAI,EAAS,oBAAoB,CAAC,GAAG,CACjC,UAAA,WAAW,IAAI,OAAA,QAAQ,CAAC,eAAe,CAAC,WAAW,EAAE,QAAQ,EAAE,WAAW,CAAC,EAA5D,CAA4D,CAAC,CAAC,CAAC;IACpF,CAAC,CAAC,CAAC;IACH,MAAM,CAAC,IAAI,CAAC,MAAM,KAAK,CAAC,GAAG,CAAC,eAAe,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;AACvF,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SecurityContext} from '@angular/core';\n\nimport {CompileDirectiveSummary, CompilePipeSummary} from '../compile_metadata';\nimport {ASTWithSource, BindingPipe, EmptyExpr, ParserError, RecursiveAstVisitor, TemplateBinding} from '../expression_parser/ast';\nimport {Parser} from '../expression_parser/parser';\nimport {isPresent} from '../facade/lang';\nimport {InterpolationConfig} from '../ml_parser/interpolation_config';\nimport {mergeNsAndName} from '../ml_parser/tags';\nimport {ParseError, ParseErrorLevel, ParseSourceSpan} from '../parse_util';\nimport {ElementSchemaRegistry} from '../schema/element_schema_registry';\nimport {CssSelector} from '../selector';\nimport {splitAtColon, splitAtPeriod} from '../util';\n\nimport {BoundElementPropertyAst, BoundEventAst, PropertyBindingType, VariableAst} from './template_ast';\n\nconst /** @type {?} */ PROPERTY_PARTS_SEPARATOR = '.';\nconst /** @type {?} */ ATTRIBUTE_PREFIX = 'attr';\nconst /** @type {?} */ CLASS_PREFIX = 'class';\nconst /** @type {?} */ STYLE_PREFIX = 'style';\n\nconst /** @type {?} */ ANIMATE_PROP_PREFIX = 'animate-';\nexport type BoundPropertyType = number;\nexport let BoundPropertyType: any = {};\nBoundPropertyType.DEFAULT = 0;\nBoundPropertyType.LITERAL_ATTR = 1;\nBoundPropertyType.ANIMATION = 2;\nBoundPropertyType[BoundPropertyType.DEFAULT] = \"DEFAULT\";\nBoundPropertyType[BoundPropertyType.LITERAL_ATTR] = \"LITERAL_ATTR\";\nBoundPropertyType[BoundPropertyType.ANIMATION] = \"ANIMATION\";\n\n/**\n *  Represents a parsed property.\n */\nexport class BoundProperty {\n/**\n * @param {?} name\n * @param {?} expression\n * @param {?} type\n * @param {?} sourceSpan\n */\nconstructor(\npublic name: string,\npublic expression: ASTWithSource,\npublic type: BoundPropertyType,\npublic sourceSpan: ParseSourceSpan) {}\n/**\n * @return {?}\n */\nget isLiteral() { return this.type === BoundPropertyType.LITERAL_ATTR; }\n/**\n * @return {?}\n */\nget isAnimation() { return this.type === BoundPropertyType.ANIMATION; }\n}\n\nfunction BoundProperty_tsickle_Closure_declarations() {\n /** @type {?} */\nBoundProperty.prototype.name;\n /** @type {?} */\nBoundProperty.prototype.expression;\n /** @type {?} */\nBoundProperty.prototype.type;\n /** @type {?} */\nBoundProperty.prototype.sourceSpan;\n}\n\n/**\n *  Parses bindings in templates and in the directive host area.\n */\nexport class BindingParser {\n  pipesByName: Map<string, CompilePipeSummary> = new Map();\n/**\n * @param {?} _exprParser\n * @param {?} _interpolationConfig\n * @param {?} _schemaRegistry\n * @param {?} pipes\n * @param {?} _targetErrors\n */\nconstructor(\nprivate _exprParser: Parser,\nprivate _interpolationConfig: InterpolationConfig,\nprivate _schemaRegistry: ElementSchemaRegistry, pipes: CompilePipeSummary[],\nprivate _targetErrors: ParseError[]) {\n    pipes.forEach(pipe => this.pipesByName.set(pipe.name, pipe));\n  }\n/**\n * @param {?} dirMeta\n * @param {?} sourceSpan\n * @return {?}\n */\ncreateDirectiveHostPropertyAsts(dirMeta: CompileDirectiveSummary, sourceSpan: ParseSourceSpan):\n      BoundElementPropertyAst[] {\n    if (dirMeta.hostProperties) {\n      const /** @type {?} */ boundProps: BoundProperty[] = [];\n      Object.keys(dirMeta.hostProperties).forEach(propName => {\n        const /** @type {?} */ expression = dirMeta.hostProperties[propName];\n        if (typeof expression === 'string') {\n          this.parsePropertyBinding(propName, expression, true, sourceSpan, [], boundProps);\n        } else {\n          this._reportError(\n              `Value of the host property binding \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`,\n              sourceSpan);\n        }\n      });\n      return boundProps.map((prop) => this.createElementPropertyAst(dirMeta.selector, prop));\n    }\n  }\n/**\n * @param {?} dirMeta\n * @param {?} sourceSpan\n * @return {?}\n */\ncreateDirectiveHostEventAsts(dirMeta: CompileDirectiveSummary, sourceSpan: ParseSourceSpan):\n      BoundEventAst[] {\n    if (dirMeta.hostListeners) {\n      const /** @type {?} */ targetEventAsts: BoundEventAst[] = [];\n      Object.keys(dirMeta.hostListeners).forEach(propName => {\n        const /** @type {?} */ expression = dirMeta.hostListeners[propName];\n        if (typeof expression === 'string') {\n          this.parseEvent(propName, expression, sourceSpan, [], targetEventAsts);\n        } else {\n          this._reportError(\n              `Value of the host listener \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`,\n              sourceSpan);\n        }\n      });\n      return targetEventAsts;\n    }\n  }\n/**\n * @param {?} value\n * @param {?} sourceSpan\n * @return {?}\n */\nparseInterpolation(value: string, sourceSpan: ParseSourceSpan): ASTWithSource {\n    const /** @type {?} */ sourceInfo = sourceSpan.start.toString();\n\n    try {\n      const /** @type {?} */ ast = this._exprParser.parseInterpolation(value, sourceInfo, this._interpolationConfig);\n      if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      this._checkPipes(ast, sourceSpan);\n      return ast;\n    } catch ( /** @type {?} */e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n    }\n  }\n/**\n * @param {?} name\n * @param {?} prefixToken\n * @param {?} value\n * @param {?} sourceSpan\n * @param {?} targetMatchableAttrs\n * @param {?} targetProps\n * @param {?} targetVars\n * @return {?}\n */\nparseInlineTemplateBinding(\n      name: string, prefixToken: string, value: string, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetProps: BoundProperty[], targetVars: VariableAst[]) {\n    const /** @type {?} */ bindings = this._parseTemplateBindings(prefixToken, value, sourceSpan);\n    for (let /** @type {?} */ i = 0; i < bindings.length; i++) {\n      const /** @type {?} */ binding = bindings[i];\n      if (binding.keyIsVar) {\n        targetVars.push(new VariableAst(binding.key, binding.name, sourceSpan));\n      } else if (isPresent(binding.expression)) {\n        this._parsePropertyAst(\n            binding.key, binding.expression, sourceSpan, targetMatchableAttrs, targetProps);\n      } else {\n        targetMatchableAttrs.push([binding.key, '']);\n        this.parseLiteralAttr(binding.key, null, sourceSpan, targetMatchableAttrs, targetProps);\n      }\n    }\n  }\n/**\n * @param {?} prefixToken\n * @param {?} value\n * @param {?} sourceSpan\n * @return {?}\n */\nprivate _parseTemplateBindings(prefixToken: string, value: string, sourceSpan: ParseSourceSpan):\n      TemplateBinding[] {\n    const /** @type {?} */ sourceInfo = sourceSpan.start.toString();\n\n    try {\n      const /** @type {?} */ bindingsResult = this._exprParser.parseTemplateBindings(prefixToken, value, sourceInfo);\n      this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);\n      bindingsResult.templateBindings.forEach((binding) => {\n        if (isPresent(binding.expression)) {\n          this._checkPipes(binding.expression, sourceSpan);\n        }\n      });\n      bindingsResult.warnings.forEach(\n          (warning) => { this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING); });\n      return bindingsResult.templateBindings;\n    } catch ( /** @type {?} */e) {\n      this._reportError(`${e}`, sourceSpan);\n      return [];\n    }\n  }\n/**\n * @param {?} name\n * @param {?} value\n * @param {?} sourceSpan\n * @param {?} targetMatchableAttrs\n * @param {?} targetProps\n * @return {?}\n */\nparseLiteralAttr(\n      name: string, value: string, sourceSpan: ParseSourceSpan, targetMatchableAttrs: string[][],\n      targetProps: BoundProperty[]) {\n    if (_isAnimationLabel(name)) {\n      name = name.substring(1);\n      if (value) {\n        this._reportError(\n            `Assigning animation triggers via @prop=\"exp\" attributes with an expression is invalid.` +\n                ` Use property bindings (e.g. [@prop]=\"exp\") or use an attribute without a value (e.g. @prop) instead.`,\n            sourceSpan, ParseErrorLevel.FATAL);\n      }\n      this._parseAnimation(name, value, sourceSpan, targetMatchableAttrs, targetProps);\n    } else {\n      targetProps.push(new BoundProperty(\n          name, this._exprParser.wrapLiteralPrimitive(value, ''), BoundPropertyType.LITERAL_ATTR,\n          sourceSpan));\n    }\n  }\n/**\n * @param {?} name\n * @param {?} expression\n * @param {?} isHost\n * @param {?} sourceSpan\n * @param {?} targetMatchableAttrs\n * @param {?} targetProps\n * @return {?}\n */\nparsePropertyBinding(\n      name: string, expression: string, isHost: boolean, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetProps: BoundProperty[]) {\n    let /** @type {?} */ isAnimationProp = false;\n    if (name.startsWith(ANIMATE_PROP_PREFIX)) {\n      isAnimationProp = true;\n      name = name.substring(ANIMATE_PROP_PREFIX.length);\n    } else if (_isAnimationLabel(name)) {\n      isAnimationProp = true;\n      name = name.substring(1);\n    }\n\n    if (isAnimationProp) {\n      this._parseAnimation(name, expression, sourceSpan, targetMatchableAttrs, targetProps);\n    } else {\n      this._parsePropertyAst(\n          name, this._parseBinding(expression, isHost, sourceSpan), sourceSpan,\n          targetMatchableAttrs, targetProps);\n    }\n  }\n/**\n * @param {?} name\n * @param {?} value\n * @param {?} sourceSpan\n * @param {?} targetMatchableAttrs\n * @param {?} targetProps\n * @return {?}\n */\nparsePropertyInterpolation(\n      name: string, value: string, sourceSpan: ParseSourceSpan, targetMatchableAttrs: string[][],\n      targetProps: BoundProperty[]): boolean {\n    const /** @type {?} */ expr = this.parseInterpolation(value, sourceSpan);\n    if (isPresent(expr)) {\n      this._parsePropertyAst(name, expr, sourceSpan, targetMatchableAttrs, targetProps);\n      return true;\n    }\n    return false;\n  }\n/**\n * @param {?} name\n * @param {?} ast\n * @param {?} sourceSpan\n * @param {?} targetMatchableAttrs\n * @param {?} targetProps\n * @return {?}\n */\nprivate _parsePropertyAst(\n      name: string, ast: ASTWithSource, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetProps: BoundProperty[]) {\n    targetMatchableAttrs.push([name, ast.source]);\n    targetProps.push(new BoundProperty(name, ast, BoundPropertyType.DEFAULT, sourceSpan));\n  }\n/**\n * @param {?} name\n * @param {?} expression\n * @param {?} sourceSpan\n * @param {?} targetMatchableAttrs\n * @param {?} targetProps\n * @return {?}\n */\nprivate _parseAnimation(\n      name: string, expression: string, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetProps: BoundProperty[]) {\n    // This will occur when a @trigger is not paired with an expression.\n    // For animations it is valid to not have an expression since */void\n    // states will be applied by angular when the element is attached/detached\n    const /** @type {?} */ ast = this._parseBinding(expression || 'null', false, sourceSpan);\n    targetMatchableAttrs.push([name, ast.source]);\n    targetProps.push(new BoundProperty(name, ast, BoundPropertyType.ANIMATION, sourceSpan));\n  }\n/**\n * @param {?} value\n * @param {?} isHostBinding\n * @param {?} sourceSpan\n * @return {?}\n */\nprivate _parseBinding(value: string, isHostBinding: boolean, sourceSpan: ParseSourceSpan):\n      ASTWithSource {\n    const /** @type {?} */ sourceInfo = sourceSpan.start.toString();\n\n    try {\n      const /** @type {?} */ ast = isHostBinding ?\n          this._exprParser.parseSimpleBinding(value, sourceInfo, this._interpolationConfig) :\n          this._exprParser.parseBinding(value, sourceInfo, this._interpolationConfig);\n      if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      this._checkPipes(ast, sourceSpan);\n      return ast;\n    } catch ( /** @type {?} */e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n    }\n  }\n/**\n * @param {?} elementSelector\n * @param {?} boundProp\n * @return {?}\n */\ncreateElementPropertyAst(elementSelector: string, boundProp: BoundProperty):\n      BoundElementPropertyAst {\n    if (boundProp.isAnimation) {\n      return new BoundElementPropertyAst(\n          boundProp.name, PropertyBindingType.Animation, SecurityContext.NONE, false,\n          boundProp.expression, null, boundProp.sourceSpan);\n    }\n\n    let /** @type {?} */ unit: string = null;\n    let /** @type {?} */ bindingType: PropertyBindingType;\n    let /** @type {?} */ boundPropertyName: string = null;\n    const /** @type {?} */ parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);\n    let /** @type {?} */ securityContexts: SecurityContext[];\n\n    // Check check for special cases (prefix style, attr, class)\n    if (parts.length > 1) {\n      if (parts[0] == ATTRIBUTE_PREFIX) {\n        boundPropertyName = parts[1];\n        this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);\n        securityContexts = calcPossibleSecurityContexts(\n            this._schemaRegistry, elementSelector, boundPropertyName, true);\n\n        const /** @type {?} */ nsSeparatorIdx = boundPropertyName.indexOf(':');\n        if (nsSeparatorIdx > -1) {\n          const /** @type {?} */ ns = boundPropertyName.substring(0, nsSeparatorIdx);\n          const /** @type {?} */ name = boundPropertyName.substring(nsSeparatorIdx + 1);\n          boundPropertyName = mergeNsAndName(ns, name);\n        }\n\n        bindingType = PropertyBindingType.Attribute;\n      } else if (parts[0] == CLASS_PREFIX) {\n        boundPropertyName = parts[1];\n        bindingType = PropertyBindingType.Class;\n        securityContexts = [SecurityContext.NONE];\n      } else if (parts[0] == STYLE_PREFIX) {\n        unit = parts.length > 2 ? parts[2] : null;\n        boundPropertyName = parts[1];\n        bindingType = PropertyBindingType.Style;\n        securityContexts = [SecurityContext.STYLE];\n      }\n    }\n\n    // If not a special case, use the full property name\n    if (boundPropertyName === null) {\n      boundPropertyName = this._schemaRegistry.getMappedPropName(boundProp.name);\n      securityContexts = calcPossibleSecurityContexts(\n          this._schemaRegistry, elementSelector, boundPropertyName, false);\n      bindingType = PropertyBindingType.Property;\n      this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, false);\n    }\n\n    return new BoundElementPropertyAst(\n        boundPropertyName, bindingType, securityContexts.length === 1 ? securityContexts[0] : null,\n        securityContexts.length > 1, boundProp.expression, unit, boundProp.sourceSpan);\n  }\n/**\n * @param {?} name\n * @param {?} expression\n * @param {?} sourceSpan\n * @param {?} targetMatchableAttrs\n * @param {?} targetEvents\n * @return {?}\n */\nparseEvent(\n      name: string, expression: string, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetEvents: BoundEventAst[]) {\n    if (_isAnimationLabel(name)) {\n      name = name.substr(1);\n      this._parseAnimationEvent(name, expression, sourceSpan, targetEvents);\n    } else {\n      this._parseEvent(name, expression, sourceSpan, targetMatchableAttrs, targetEvents);\n    }\n  }\n/**\n * @param {?} name\n * @param {?} expression\n * @param {?} sourceSpan\n * @param {?} targetEvents\n * @return {?}\n */\nprivate _parseAnimationEvent(\n      name: string, expression: string, sourceSpan: ParseSourceSpan,\n      targetEvents: BoundEventAst[]) {\n    const /** @type {?} */ matches = splitAtPeriod(name, [name, '']);\n    const /** @type {?} */ eventName = matches[0];\n    const /** @type {?} */ phase = matches[1].toLowerCase();\n    if (phase) {\n      switch (phase) {\n        case 'start':\n        case 'done':\n          const /** @type {?} */ ast = this._parseAction(expression, sourceSpan);\n          targetEvents.push(new BoundEventAst(eventName, null, phase, ast, sourceSpan));\n          break;\n\n        default:\n          this._reportError(\n              `The provided animation output phase value \"${phase}\" for \"@${eventName}\" is not supported (use start or done)`,\n              sourceSpan);\n          break;\n      }\n    } else {\n      this._reportError(\n          `The animation trigger output event (@${eventName}) is missing its phase value name (start or done are currently supported)`,\n          sourceSpan);\n    }\n  }\n/**\n * @param {?} name\n * @param {?} expression\n * @param {?} sourceSpan\n * @param {?} targetMatchableAttrs\n * @param {?} targetEvents\n * @return {?}\n */\nprivate _parseEvent(\n      name: string, expression: string, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetEvents: BoundEventAst[]) {\n    // long format: 'target: eventName'\n    const [target, eventName] = splitAtColon(name, [null, name]);\n    const /** @type {?} */ ast = this._parseAction(expression, sourceSpan);\n    targetMatchableAttrs.push([name, ast.source]);\n    targetEvents.push(new BoundEventAst(eventName, target, null, ast, sourceSpan));\n    // Don't detect directives for event names for now,\n    // so don't add the event name to the matchableAttrs\n  }\n/**\n * @param {?} value\n * @param {?} sourceSpan\n * @return {?}\n */\nprivate _parseAction(value: string, sourceSpan: ParseSourceSpan): ASTWithSource {\n    const /** @type {?} */ sourceInfo = sourceSpan.start.toString();\n\n    try {\n      const /** @type {?} */ ast = this._exprParser.parseAction(value, sourceInfo, this._interpolationConfig);\n      if (ast) {\n        this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      }\n      if (!ast || ast.ast instanceof EmptyExpr) {\n        this._reportError(`Empty expressions are not allowed`, sourceSpan);\n        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n      }\n      this._checkPipes(ast, sourceSpan);\n      return ast;\n    } catch ( /** @type {?} */e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n    }\n  }\n/**\n * @param {?} message\n * @param {?} sourceSpan\n * @param {?=} level\n * @return {?}\n */\nprivate _reportError(\n      message: string, sourceSpan: ParseSourceSpan,\n      level: ParseErrorLevel = ParseErrorLevel.FATAL) {\n    this._targetErrors.push(new ParseError(sourceSpan, message, level));\n  }\n/**\n * @param {?} errors\n * @param {?} sourceSpan\n * @return {?}\n */\nprivate _reportExpressionParserErrors(errors: ParserError[], sourceSpan: ParseSourceSpan) {\n    for (const /** @type {?} */ error of errors) {\n      this._reportError(error.message, sourceSpan);\n    }\n  }\n/**\n * @param {?} ast\n * @param {?} sourceSpan\n * @return {?}\n */\nprivate _checkPipes(ast: ASTWithSource, sourceSpan: ParseSourceSpan) {\n    if (isPresent(ast)) {\n      const /** @type {?} */ collector = new PipeCollector();\n      ast.visit(collector);\n      collector.pipes.forEach((ast, pipeName) => {\n        if (!this.pipesByName.has(pipeName)) {\n          this._reportError(\n              `The pipe '${pipeName}' could not be found`,\n              new ParseSourceSpan(\n                  sourceSpan.start.moveBy(ast.span.start), sourceSpan.start.moveBy(ast.span.end)));\n        }\n      });\n    }\n  }\n/**\n * @param {?} propName the name of the property / attribute\n * @param {?} sourceSpan\n * @param {?} isAttr true when binding to an attribute\n * @return {?}\n */\nprivate _validatePropertyOrAttributeName(\n      propName: string, sourceSpan: ParseSourceSpan, isAttr: boolean): void {\n    const /** @type {?} */ report = isAttr ? this._schemaRegistry.validateAttribute(propName) :\n                            this._schemaRegistry.validateProperty(propName);\n    if (report.error) {\n      this._reportError(report.msg, sourceSpan, ParseErrorLevel.FATAL);\n    }\n  }\n}\n\nfunction BindingParser_tsickle_Closure_declarations() {\n /** @type {?} */\nBindingParser.prototype.pipesByName;\n /** @type {?} */\nBindingParser.prototype._exprParser;\n /** @type {?} */\nBindingParser.prototype._interpolationConfig;\n /** @type {?} */\nBindingParser.prototype._schemaRegistry;\n /** @type {?} */\nBindingParser.prototype._targetErrors;\n}\n\n\nexport class PipeCollector extends RecursiveAstVisitor {\n  pipes = new Map<string, BindingPipe>();\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitPipe(ast: BindingPipe, context: any): any {\n    this.pipes.set(ast.name, ast);\n    ast.exp.visit(this);\n    this.visitAll(ast.args, context);\n    return null;\n  }\n}\n\nfunction PipeCollector_tsickle_Closure_declarations() {\n /** @type {?} */\nPipeCollector.prototype.pipes;\n}\n\n/**\n * @param {?} name\n * @return {?}\n */\nfunction _isAnimationLabel(name: string): boolean {\n  return name[0] == '@';\n}\n/**\n * @param {?} registry\n * @param {?} selector\n * @param {?} propName\n * @param {?} isAttribute\n * @return {?}\n */\nexport function calcPossibleSecurityContexts(\n    registry: ElementSchemaRegistry, selector: string, propName: string,\n    isAttribute: boolean): SecurityContext[] {\n  const /** @type {?} */ ctxs: SecurityContext[] = [];\n  CssSelector.parse(selector).forEach((selector) => {\n    const /** @type {?} */ elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();\n    const /** @type {?} */ notElementNames =\n        new Set(selector.notSelectors.filter(selector => selector.isElementSelector())\n                    .map((selector) => selector.element));\n    const /** @type {?} */ possibleElementNames =\n        elementNames.filter(elementName => !notElementNames.has(elementName));\n\n    ctxs.push(...possibleElementNames.map(\n        elementName => registry.securityContext(elementName, propName, isAttribute)));\n  });\n  return ctxs.length === 0 ? [SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}