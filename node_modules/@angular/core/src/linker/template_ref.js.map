{"version":3,"file":"template_ref.js","sourceRoot":"","sources":["../../../../../modules/@angular/core/src/linker/template_ref.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;;;;;;OAEI,EAAC,UAAU,EAAC,MAAM,eAAe;AAIxC;;;;;;;;;;;;GAYG;AACH;IAAA;IAWA,CAAC;IAPD,sBAAI,mCAAU;QAHd;;WAEG;aACH,cAA+B,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;;;OAAA;IAC7C;;;;OAIG;IACH,wCAAkB,GAAlB,UAAmB,OAAU,IAAG,CAAC;IACjC,kBAAC;AAAD,CAAC,AAXD,IAWC;AAED;IAAqC,gCAAc;IACnD;;;;OAIG;IACH,sBACQ,WAAyB,EACzB,UAAkB,EAClB,cAAmB;QACvB,iBAAO,CAAC;QAHJ,gBAAW,GAAX,WAAW,CAAc;QACzB,eAAU,GAAV,UAAU,CAAQ;QAClB,mBAAc,GAAd,cAAc,CAAK;IAEzB,CAAC;IACH;;;OAGG;IACH,yCAAkB,GAAlB,UAAmB,OAAU;QACzB,IAAM,gBAAgB,CAAC,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,0BAA0B,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAC3F,IAAI,CAAC,MAAM,CAAC,OAAO,IAAoB,CAAQ,EAAG,CAAC,CAAC,CAAC;QACrD,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC;IAClB,CAAC;IAIH,sBAAI,oCAAU;QAHd;;WAEG;aACH,cAA+B,MAAM,CAAC,IAAI,UAAU,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC;;;OAAA;IAC5E,mBAAC;AAAD,CAAC,AAzBD,CAAqC,WAAW,GAyB/C;AAED;IACC,gBAAgB;IACjB,YAAY,CAAC,SAAS,CAAC,WAAW,CAAC;IAClC,gBAAgB;IACjB,YAAY,CAAC,SAAS,CAAC,UAAU,CAAC;IACjC,gBAAgB;IACjB,YAAY,CAAC,SAAS,CAAC,cAAc,CAAC;AACtC,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ElementRef} from './element_ref';\nimport {AppView} from './view';\nimport {ViewContainer} from './view_container';\nimport {EmbeddedViewRef} from './view_ref';\n/**\n *  Represents an Embedded Template that can be used to instantiate Embedded Views.\n  * *\n  * You can access a `TemplateRef`, in two ways. Via a directive placed on a `<template>` element (or\n  * directive prefixed with `*`) and have the `TemplateRef` for this Embedded View injected into the\n  * constructor of the directive using the `TemplateRef` Token. Alternatively you can query for the\n  * `TemplateRef` from a Component or a Directive via {@link Query}.\n  * *\n  * To instantiate Embedded Views based on a Template, use\n  * {@link ViewContainerRef#createEmbeddedView}, which will create the View and attach it to the\n  * View Container.\n * @abstract\n */\nexport abstract class TemplateRef<C> {\n/**\n * @return {?}\n */\nget elementRef(): ElementRef { return null; }\n/**\n * @abstract\n * @param {?} context\n * @return {?}\n */\ncreateEmbeddedView(context: C) {}\n}\n\nexport class TemplateRef_<C> extends TemplateRef<C> {\n/**\n * @param {?} _parentView\n * @param {?} _nodeIndex\n * @param {?} _nativeElement\n */\nconstructor(\nprivate _parentView: AppView<any>,\nprivate _nodeIndex: number,\nprivate _nativeElement: any) {\n    super();\n  }\n/**\n * @param {?} context\n * @return {?}\n */\ncreateEmbeddedView(context: C): EmbeddedViewRef<C> {\n    const /** @type {?} */ view = this._parentView.createEmbeddedViewInternal(this._nodeIndex);\n    view.create(context || /** @type {?} */(( <any>{})));\n    return view.ref;\n  }\n/**\n * @return {?}\n */\nget elementRef(): ElementRef { return new ElementRef(this._nativeElement); }\n}\n\nfunction TemplateRef__tsickle_Closure_declarations() {\n /** @type {?} */\nTemplateRef_.prototype._parentView;\n /** @type {?} */\nTemplateRef_.prototype._nodeIndex;\n /** @type {?} */\nTemplateRef_.prototype._nativeElement;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}