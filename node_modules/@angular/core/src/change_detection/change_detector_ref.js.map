{"version":3,"file":"change_detector_ref.js","sourceRoot":"","sources":["../../../../../modules/@angular/core/src/change_detection/change_detector_ref.ts"],"names":[],"mappings":"AACA;;GAEG;AACH;IAAA;IAqLA,CAAC;IApLD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAmCG;IACH,wCAAY,GAAZ,cAAgB,CAAC;IACjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAoDG;IACH,kCAAM,GAAN,cAAU,CAAC;IACX;;;;;;;;;;;;;;;;;;;;;;;OAuBG;IACH,yCAAa,GAAb,cAAiB,CAAC;IAClB;;;;;;;OAOG;IACH,0CAAc,GAAd,cAAkB,CAAC;IACnB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAqDG;IACH,oCAAQ,GAAR,cAAY,CAAC;IACb,wBAAC;AAAD,CAAC,AArLD,IAqLC","sourcesContent":["\n/**\n * @abstract\n */\nexport abstract class ChangeDetectorRef {\n/**\n *  Marks all {@link ChangeDetectionStrategy#OnPush} ancestors as to be checked.\n  * *\n  * <!-- TODO: Add a link to a chapter on OnPush components -->\n  * *\n  * ### Example ([live demo](http://plnkr.co/edit/GC512b?p=preview))\n  * *\n  * ```typescript\n  * selector: 'cmp',\n  * changeDetection: ChangeDetectionStrategy.OnPush,\n  * template: `Number of ticks: {{numberOfTicks}}`\n  * })\n  * class Cmp {\n  * numberOfTicks = 0;\n  * *\n  * constructor(ref: ChangeDetectorRef) {\n  * setInterval(() => {\n  * this.numberOfTicks ++\n  * // the following is required, otherwise the view will not be updated\n  * this.ref.markForCheck();\n  * }, 1000);\n  * }\n  * }\n  * *\n  * selector: 'app',\n  * changeDetection: ChangeDetectionStrategy.OnPush,\n  * template: `\n  * <cmp><cmp>\n  * `,\n  * })\n  * class App {\n  * }\n  * ```\n * @abstract\n * @return {?}\n */\nmarkForCheck() {}\n/**\n *  Detaches the change detector from the change detector tree.\n  * *\n  * The detached change detector will not be checked until it is reattached.\n  * *\n  * This can also be used in combination with {@link ChangeDetectorRef#detectChanges} to implement\n  * local change\n  * detection checks.\n  * *\n  * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n  * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n  * *\n  * ### Example\n  * *\n  * The following example defines a component with a large list of readonly data.\n  * Imagine the data changes constantly, many times per second. For performance reasons,\n  * we want to check and update the list every five seconds. We can do that by detaching\n  * the component's change detector and doing a local check every five seconds.\n  * *\n  * ```typescript\n  * class DataProvider {\n  * // in a real application the returned data will be different every time\n  * get data() {\n  * return [1,2,3,4,5];\n  * }\n  * }\n  * *\n  * selector: 'giant-list',\n  * template: `\n  * <li *ngFor=\"let d of dataProvider.data\">Data {{d}}</lig>\n  * `,\n  * })\n  * class GiantList {\n  * constructor(private ref: ChangeDetectorRef, private dataProvider:DataProvider) {\n  * ref.detach();\n  * setInterval(() => {\n  * this.ref.detectChanges();\n  * }, 5000);\n  * }\n  * }\n  * *\n  * selector: 'app',\n  * providers: [DataProvider],\n  * template: `\n  * <giant-list><giant-list>\n  * `,\n  * })\n  * class App {\n  * }\n  * ```\n * @abstract\n * @return {?}\n */\ndetach() {}\n/**\n *  Checks the change detector and its children.\n  * *\n  * This can also be used in combination with {@link ChangeDetectorRef#detach} to implement local\n  * change detection\n  * checks.\n  * *\n  * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n  * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n  * *\n  * ### Example\n  * *\n  * The following example defines a component with a large list of readonly data.\n  * Imagine, the data changes constantly, many times per second. For performance reasons,\n  * we want to check and update the list every five seconds.\n  * *\n  * We can do that by detaching the component's change detector and doing a local change detection\n  * check\n  * every five seconds.\n  * *\n  * See {@link ChangeDetectorRef#detach} for more information.\n * @abstract\n * @return {?}\n */\ndetectChanges() {}\n/**\n *  Checks the change detector and its children, and throws if any changes are detected.\n  * *\n  * This is used in development mode to verify that running change detection doesn't introduce\n  * other changes.\n * @abstract\n * @return {?}\n */\ncheckNoChanges() {}\n/**\n *  Reattach the change detector to the change detector tree.\n  * *\n  * This also marks OnPush ancestors as to be checked. This reattached change detector will be\n  * checked during the next change detection run.\n  * *\n  * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n  * *\n  * ### Example ([live demo](http://plnkr.co/edit/aUhZha?p=preview))\n  * *\n  * The following example creates a component displaying `live` data. The component will detach\n  * its change detector from the main change detector tree when the component's live property\n  * is set to false.\n  * *\n  * ```typescript\n  * class DataProvider {\n  * data = 1;\n  * *\n  * constructor() {\n  * setInterval(() => {\n  * this.data = this.data * 2;\n  * }, 500);\n  * }\n  * }\n  * *\n  * selector: 'live-data',\n  * inputs: ['live'],\n  * template: 'Data: {{dataProvider.data}}'\n  * })\n  * class LiveData {\n  * constructor(private ref: ChangeDetectorRef, private dataProvider:DataProvider) {}\n  * *\n  * set live(value) {\n  * if (value)\n  * this.ref.reattach();\n  * else\n  * this.ref.detach();\n  * }\n  * }\n  * *\n  * selector: 'app',\n  * providers: [DataProvider],\n  * template: `\n  * Live Update: <input type=\"checkbox\" [(ngModel)]=\"live\">\n  * <live-data [live]=\"live\"><live-data>\n  * `,\n  * })\n  * class App {\n  * live = true;\n  * }\n  * ```\n * @abstract\n * @return {?}\n */\nreattach() {}\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}