"use strict";
var fs = require('fs');
var path = require('path');
var ts = require('typescript');
var compiler_cli_1 = require('@angular/compiler-cli');
var ContextElementDependency = require('webpack/lib/dependencies/ContextElementDependency');
var resource_loader_1 = require('./resource_loader');
var compiler_host_1 = require('./compiler_host');
var entry_resolver_1 = require('./entry_resolver');
var paths_plugin_1 = require('./paths-plugin');
var lazy_routes_1 = require('./lazy_routes');
var AotPlugin = (function () {
    function AotPlugin(options) {
        this._lazyRoutes = Object.create(null);
        this._compiler = null;
        this._compilation = null;
        this._typeCheck = true;
        this._skipCodeGeneration = false;
        this._diagnoseFiles = {};
        this._firstRun = true;
        this._setupOptions(options);
    }
    Object.defineProperty(AotPlugin.prototype, "basePath", {
        get: function () { return this._basePath; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AotPlugin.prototype, "compilation", {
        get: function () { return this._compilation; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AotPlugin.prototype, "compilerHost", {
        get: function () { return this._compilerHost; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AotPlugin.prototype, "compilerOptions", {
        get: function () { return this._compilerOptions; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AotPlugin.prototype, "done", {
        get: function () { return this._donePromise; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AotPlugin.prototype, "entryModule", {
        get: function () {
            var splitted = this._entryModule.split('#');
            var path = splitted[0];
            var className = splitted[1] || 'default';
            return { path: path, className: className };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AotPlugin.prototype, "genDir", {
        get: function () { return this._genDir; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AotPlugin.prototype, "program", {
        get: function () { return this._program; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AotPlugin.prototype, "skipCodeGeneration", {
        get: function () { return this._skipCodeGeneration; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AotPlugin.prototype, "typeCheck", {
        get: function () { return this._typeCheck; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AotPlugin.prototype, "i18nFile", {
        get: function () { return this._i18nFile; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AotPlugin.prototype, "i18nFormat", {
        get: function () { return this._i18nFormat; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AotPlugin.prototype, "locale", {
        get: function () { return this._locale; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AotPlugin.prototype, "firstRun", {
        get: function () { return this._firstRun; },
        enumerable: true,
        configurable: true
    });
    AotPlugin.prototype._setupOptions = function (options) {
        // Fill in the missing options.
        if (!options.hasOwnProperty('tsConfigPath')) {
            throw new Error('Must specify "tsConfigPath" in the configuration of @ngtools/webpack.');
        }
        this._tsConfigPath = options.tsConfigPath;
        // Check the base path.
        var maybeBasePath = path.resolve(process.cwd(), this._tsConfigPath);
        var basePath = maybeBasePath;
        if (fs.statSync(maybeBasePath).isFile()) {
            basePath = path.dirname(basePath);
        }
        if (options.hasOwnProperty('basePath')) {
            basePath = path.resolve(process.cwd(), options.basePath);
        }
        var tsConfigJson = null;
        try {
            tsConfigJson = JSON.parse(fs.readFileSync(this._tsConfigPath, 'utf8'));
        }
        catch (err) {
            throw new Error("An error happened while parsing " + this._tsConfigPath + " JSON: " + err + ".");
        }
        var tsConfig = ts.parseJsonConfigFileContent(tsConfigJson, ts.sys, basePath, null, this._tsConfigPath);
        var fileNames = tsConfig.fileNames;
        if (options.hasOwnProperty('exclude')) {
            var exclude = typeof options.exclude == 'string'
                ? [options.exclude] : options.exclude;
            exclude.forEach(function (pattern) {
                var basePathPattern = '(' + basePath.replace(/\\/g, '/')
                    .replace(/[\-\[\]\/{}()+?.\\^$|*]/g, '\\$&') + ')?';
                pattern = pattern
                    .replace(/\\/g, '/')
                    .replace(/[\-\[\]{}()+?.\\^$|]/g, '\\$&')
                    .replace(/\*\*/g, '(?:.*)')
                    .replace(/\*/g, '(?:[^/]*)')
                    .replace(/^/, basePathPattern);
                var re = new RegExp('^' + pattern + '$');
                fileNames = fileNames.filter(function (x) { return !x.replace(/\\/g, '/').match(re); });
            });
        }
        else {
            fileNames = fileNames.filter(function (fileName) { return !/\.spec\.ts$/.test(fileName); });
        }
        this._rootFilePath = fileNames;
        // Check the genDir. We generate a default gendir that's under basepath; it will generate
        // a `node_modules` directory and because of that we don't want TypeScript resolution to
        // resolve to that directory but the real `node_modules`.
        var genDir = path.join(basePath, '$$_gendir');
        this._compilerOptions = tsConfig.options;
        this._angularCompilerOptions = Object.assign({ genDir: genDir }, this._compilerOptions, tsConfig.raw['angularCompilerOptions'], { basePath: basePath });
        if (this._angularCompilerOptions.hasOwnProperty('genDir')) {
            genDir = path.resolve(basePath, this._angularCompilerOptions.genDir);
            this._angularCompilerOptions.genDir = genDir;
        }
        this._basePath = basePath;
        this._genDir = genDir;
        if (options.hasOwnProperty('typeChecking')) {
            this._typeCheck = options.typeChecking;
        }
        if (options.hasOwnProperty('skipCodeGeneration')) {
            this._skipCodeGeneration = options.skipCodeGeneration;
        }
        this._compilerHost = new compiler_host_1.WebpackCompilerHost(this._compilerOptions, this._basePath);
        this._program = ts.createProgram(this._rootFilePath, this._compilerOptions, this._compilerHost);
        // We enable caching of the filesystem in compilerHost _after_ the program has been created,
        // because we don't want SourceFile instances to be cached past this point.
        this._compilerHost.enableCaching();
        if (options.entryModule) {
            this._entryModule = options.entryModule;
        }
        else if (tsConfig.raw['angularCompilerOptions']
            && tsConfig.raw['angularCompilerOptions'].entryModule) {
            this._entryModule = path.resolve(this._basePath, tsConfig.raw['angularCompilerOptions'].entryModule);
        }
        // still no _entryModule? => try to resolve from mainPath
        if (!this._entryModule && options.mainPath) {
            this._entryModule = entry_resolver_1.resolveEntryModuleFromMain(options.mainPath, this._compilerHost, this._program);
        }
        if (options.hasOwnProperty('i18nFile')) {
            this._i18nFile = options.i18nFile;
        }
        if (options.hasOwnProperty('i18nFormat')) {
            this._i18nFormat = options.i18nFormat;
        }
        if (options.hasOwnProperty('locale')) {
            this._locale = options.locale;
        }
    };
    AotPlugin.prototype._findLazyRoutesInAst = function () {
        var result = Object.create(null);
        var changedFilePaths = this._compilerHost.getChangedFilePaths();
        for (var _i = 0, changedFilePaths_1 = changedFilePaths; _i < changedFilePaths_1.length; _i++) {
            var filePath = changedFilePaths_1[_i];
            var fileLazyRoutes = lazy_routes_1.findLazyRoutes(filePath, this._program, this._compilerHost);
            for (var _a = 0, _b = Object.keys(fileLazyRoutes); _a < _b.length; _a++) {
                var routeKey = _b[_a];
                var route = fileLazyRoutes[routeKey];
                if (routeKey in this._lazyRoutes) {
                    if (route === null) {
                        this._lazyRoutes[routeKey] = null;
                    }
                    else if (this._lazyRoutes[routeKey] !== route) {
                        this._compilation.warnings.push(new Error("Duplicated path in loadChildren detected during a rebuild. "
                            + "We will take the latest version detected and override it to save rebuild time. "
                            + "You should perform a full build to validate that your routes don't overlap."));
                    }
                }
                else {
                    result[routeKey] = route;
                }
            }
        }
        return result;
    };
    // registration hook for webpack plugin
    AotPlugin.prototype.apply = function (compiler) {
        var _this = this;
        this._compiler = compiler;
        compiler.plugin('invalid', function (fileName) {
            // Turn this off as soon as a file becomes invalid and we're about to start a rebuild.
            _this._firstRun = false;
            _this._diagnoseFiles = {};
            _this._compilerHost.invalidate(fileName);
        });
        // Add lazy modules to the context module for @angular/core/src/linker
        compiler.plugin('context-module-factory', function (cmf) {
            cmf.plugin('after-resolve', function (result, callback) {
                if (!result) {
                    return callback();
                }
                // alter only request from @angular/core/src/linker
                if (!result.resource.endsWith(path.join('@angular/core/src/linker'))) {
                    return callback(null, result);
                }
                _this.done.then(function () {
                    result.resource = _this.skipCodeGeneration ? _this.basePath : _this.genDir;
                    result.recursive = true;
                    result.dependencies.forEach(function (d) { return d.critical = false; });
                    result.resolveDependencies = function (p1, p2, p3, p4, cb) {
                        var dependencies = Object.keys(_this._lazyRoutes)
                            .map(function (key) {
                            var value = _this._lazyRoutes[key];
                            if (value !== null) {
                                return new ContextElementDependency(value, key);
                            }
                            else {
                                return null;
                            }
                        })
                            .filter(function (x) { return !!x; });
                        cb(null, dependencies);
                    };
                    return callback(null, result);
                }, function () { return callback(null); })
                    .catch(function (err) { return callback(err); });
            });
        });
        compiler.plugin('make', function (compilation, cb) { return _this._make(compilation, cb); });
        compiler.plugin('after-emit', function (compilation, cb) {
            _this._donePromise = null;
            _this._compilation = null;
            compilation._ngToolsWebpackPluginInstance = null;
            cb();
        });
        compiler.plugin('after-resolvers', function (compiler) {
            // Virtual file system.
            compiler.resolvers.normal.plugin('before-resolve', function (request, cb) {
                if (request.request.match(/\.ts$/)) {
                    _this.done.then(function () { return cb(); }, function () { return cb(); });
                }
                else {
                    cb();
                }
            });
            compiler.resolvers.normal.apply(new paths_plugin_1.PathsPlugin({
                tsConfigPath: _this._tsConfigPath,
                compilerOptions: _this._compilerOptions,
                compilerHost: _this._compilerHost
            }));
        });
    };
    AotPlugin.prototype.diagnose = function (fileName) {
        if (this._diagnoseFiles[fileName]) {
            return;
        }
        this._diagnoseFiles[fileName] = true;
        var sourceFile = this._program.getSourceFile(fileName);
        if (!sourceFile) {
            return;
        }
        var diagnostics = []
            .concat(this._program.getCompilerOptions().declaration
            ? this._program.getDeclarationDiagnostics(sourceFile) : [], this._program.getSyntacticDiagnostics(sourceFile), this._program.getSemanticDiagnostics(sourceFile));
        if (diagnostics.length > 0) {
            var message = diagnostics
                .map(function (diagnostic) {
                var _a = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start), line = _a.line, character = _a.character;
                var message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
                return diagnostic.file.fileName + " (" + (line + 1) + "," + (character + 1) + "): " + message + ")";
            })
                .join('\n');
            this._compilation.errors.push(message);
        }
    };
    AotPlugin.prototype._make = function (compilation, cb) {
        var _this = this;
        this._compilation = compilation;
        if (this._compilation._ngToolsWebpackPluginInstance) {
            return cb(new Error('An @ngtools/webpack plugin already exist for this compilation.'));
        }
        this._compilation._ngToolsWebpackPluginInstance = this;
        this._resourceLoader = new resource_loader_1.WebpackResourceLoader(compilation);
        this._donePromise = Promise.resolve()
            .then(function () {
            if (_this._skipCodeGeneration) {
                return;
            }
            // Create the Code Generator.
            return compiler_cli_1.__NGTOOLS_PRIVATE_API_2.codeGen({
                basePath: _this._basePath,
                compilerOptions: _this._compilerOptions,
                program: _this._program,
                host: _this._compilerHost,
                angularCompilerOptions: _this._angularCompilerOptions,
                i18nFile: _this.i18nFile,
                i18nFormat: _this.i18nFormat,
                locale: _this.locale,
                readResource: function (path) { return _this._resourceLoader.get(path); }
            });
        })
            .then(function () {
            // Create a new Program, based on the old one. This will trigger a resolution of all
            // transitive modules, which include files that might just have been generated.
            // This needs to happen after the code generator has been created for generated files
            // to be properly resolved.
            _this._program = ts.createProgram(_this._rootFilePath, _this._compilerOptions, _this._compilerHost, _this._program);
        })
            .then(function () {
            if (_this._typeCheck) {
                var diagnostics = _this._program.getGlobalDiagnostics();
                if (diagnostics.length > 0) {
                    var message = diagnostics
                        .map(function (diagnostic) {
                        var _a = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start), line = _a.line, character = _a.character;
                        var message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
                        return diagnostic.file.fileName + " (" + (line + 1) + "," + (character + 1) + "): " + message + ")";
                    })
                        .join('\n');
                    throw new Error(message);
                }
            }
        })
            .then(function () {
            // Populate the file system cache with the virtual module.
            _this._compilerHost.populateWebpackResolver(_this._compiler.resolvers.normal);
        })
            .then(function () {
            // We need to run the `listLazyRoutes` the first time because it also navigates libraries
            // and other things that we might miss using the findLazyRoutesInAst.
            var discoveredLazyRoutes = _this.firstRun ?
                compiler_cli_1.__NGTOOLS_PRIVATE_API_2.listLazyRoutes({
                    program: _this._program,
                    host: _this._compilerHost,
                    angularCompilerOptions: _this._angularCompilerOptions,
                    entryModule: _this._entryModule
                })
                : _this._findLazyRoutesInAst();
            // Process the lazy routes discovered.
            Object.keys(discoveredLazyRoutes)
                .forEach(function (k) {
                var lazyRoute = discoveredLazyRoutes[k];
                k = k.split('#')[0];
                if (lazyRoute === null) {
                    return;
                }
                if (_this.skipCodeGeneration) {
                    _this._lazyRoutes[k] = lazyRoute;
                }
                else {
                    var lr = path.relative(_this.basePath, lazyRoute.replace(/\.ts$/, '.ngfactory.ts'));
                    _this._lazyRoutes[k + '.ngfactory'] = path.join(_this.genDir, lr);
                }
            });
        })
            .then(function () {
            _this._compilerHost.resetChangedFileTracker();
            cb();
        }, function (err) {
            compilation.errors.push(err);
            cb();
        });
    };
    return AotPlugin;
}());
exports.AotPlugin = AotPlugin;
//# sourceMappingURL=/Users/hans/Sources/angular-cli/packages/@ngtools/webpack/src/plugin.js.map