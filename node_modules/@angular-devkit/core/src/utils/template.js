"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const source_map_1 = require("source-map");
// Matches <%= expr %>. This does not support structural JavaScript (for/if/...).
const kInterpolateRe = /<%=([\s\S]+?)%>/g;
// Matches <%# text %>. It's a comment and will be entirely ignored.
const kCommentRe = /<%#([\s\S]+?)%>/g;
// Used to match template delimiters.
// <%- expr %>: HTML escape the value.
// <% ... %>: Structural template code.
const kEscapeRe = /<%-([\s\S]+?)%>/g;
const kEvaluateRe = /<%([\s\S]+?)%>/g;
/** Used to map characters to HTML entities. */
const kHtmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '`': '&#96;',
};
// Used to match HTML entities and HTML characters.
const reUnescapedHtml = new RegExp(`[${Object.keys(kHtmlEscapes).join('')}]`, 'g');
function _positionFor(content, offset) {
    let line = 1;
    let column = 0;
    for (let i = 0; i < offset - 1; i++) {
        if (content[i] == '\n') {
            line++;
            column = 0;
        }
        else {
            column++;
        }
    }
    return {
        line,
        column,
    };
}
/**
 * Given a source text (and a fileName), returns a TemplateAst.
 */
function templateParser(sourceText, fileName) {
    const children = [];
    // Compile the regexp to match each delimiter.
    const reExpressions = [kEscapeRe, kCommentRe, kInterpolateRe, kEvaluateRe];
    const reDelimiters = RegExp(reExpressions.map(x => x.source).join('|') + '|$', 'g');
    const parsed = sourceText.split(reDelimiters);
    let offset = 0;
    // Optimization that uses the fact that the end of a node is always the beginning of the next
    // node, so we keep the positioning of the nodes in memory.
    let start = _positionFor(sourceText, offset);
    let end = null;
    const increment = reExpressions.length + 1;
    for (let i = 0; i < parsed.length; i += increment) {
        const [content, escape, comment, interpolate, evaluate] = parsed.slice(i, i + increment);
        if (content) {
            end = _positionFor(sourceText, offset + content.length);
            offset += content.length;
            children.push({ kind: 'content', content, start, end });
            start = end;
        }
        if (escape) {
            end = _positionFor(sourceText, offset + escape.length + 5);
            offset += escape.length + 5;
            children.push({ kind: 'escape', expression: escape, start, end });
            start = end;
        }
        if (comment) {
            end = _positionFor(sourceText, offset + comment.length + 5);
            offset += comment.length + 5;
            children.push({ kind: 'comment', text: comment, start, end });
            start = end;
        }
        if (interpolate) {
            end = _positionFor(sourceText, offset + interpolate.length + 5);
            offset += interpolate.length + 5;
            children.push({
                kind: 'interpolate',
                expression: interpolate,
                start,
                end,
            });
            start = end;
        }
        if (evaluate) {
            end = _positionFor(sourceText, offset + evaluate.length + 5);
            offset += evaluate.length + 5;
            children.push({ kind: 'evaluate', expression: evaluate, start, end });
            start = end;
        }
    }
    return {
        fileName,
        content: sourceText,
        children,
    };
}
exports.templateParser = templateParser;
/**
 * Fastest implementation of the templating algorithm. It only add strings and does not bother
 * with source maps.
 */
function templateFast(ast, options) {
    const module = options && options.module ? 'module.exports.default =' : '';
    const reHtmlEscape = reUnescapedHtml.source.replace(/[']/g, '\\\\\\\'');
    return `
    return ${module} function(obj) {
      obj || (obj = {});
      let __t;
      let __p = '';
      const __escapes = ${JSON.stringify(kHtmlEscapes)};
      const __escapesre = new RegExp('${reHtmlEscape}', 'g');

      const __e = function(s) {
        return s ? s.replace(__escapesre, function(key) { return __escapes[key]; }) : '';
      };
      with (obj) {
        ${ast.children.map(node => {
        switch (node.kind) {
            case 'content':
                return `__p += ${JSON.stringify(node.content)};`;
            case 'interpolate':
                return `__p += ((__t = (${node.expression})) == null) ? '' : __t;`;
            case 'escape':
                return `__p += __e(${node.expression});`;
            case 'evaluate':
                return node.expression;
        }
    }).join('\n')}
      }

      return __p;
    };
  `;
}
/**
 * Templating algorithm with source map support. The map is outputted as //# sourceMapUrl=...
 */
function templateWithSourceMap(ast, options) {
    const sourceUrl = ast.fileName;
    const module = options && options.module ? 'module.exports.default =' : '';
    const reHtmlEscape = reUnescapedHtml.source.replace(/[']/g, '\\\\\\\'');
    const preamble = (new source_map_1.SourceNode(1, 0, sourceUrl, ''))
        .add(new source_map_1.SourceNode(1, 0, sourceUrl, [
        `return ${module} function(obj) {\n`,
        '  obj || (obj = {});\n',
        '  let __t;\n',
        '  let __p = "";\n',
        `  const __escapes = ${JSON.stringify(kHtmlEscapes)};\n`,
        `  const __escapesre = new RegExp('${reHtmlEscape}', 'g');\n`,
        `\n`,
        `  const __e = function(s) { `,
        `    return s ? s.replace(__escapesre, function(key) { return __escapes[key]; }) : '';`,
        `  };\n`,
        `  with (obj) {\n`,
    ]));
    const end = ast.children.length
        ? ast.children[ast.children.length - 1].end
        : { line: 0, column: 0 };
    const nodes = ast.children.reduce((chunk, node) => {
        let code = '';
        switch (node.kind) {
            case 'content':
                code = [
                    new source_map_1.SourceNode(node.start.line, node.start.column, sourceUrl, '__p = __p'),
                    ...node.content.split('\n').map((line, i, arr) => {
                        return new source_map_1.SourceNode(node.start.line + i, i == 0 ? node.start.column : 0, sourceUrl, '\n    + '
                            + JSON.stringify(line + (i == arr.length - 1 ? '' : '\n')));
                    }),
                    new source_map_1.SourceNode(node.end.line, node.end.column, sourceUrl, ';\n'),
                ];
                break;
            case 'interpolate':
                code = [
                    new source_map_1.SourceNode(node.start.line, node.start.column, sourceUrl, '__p += ((__t = '),
                    ...node.expression.split('\n').map((line, i, arr) => {
                        return new source_map_1.SourceNode(node.start.line + i, i == 0 ? node.start.column : 0, sourceUrl, line + ((i == arr.length - 1) ? '' : '\n'));
                    }),
                    new source_map_1.SourceNode(node.end.line, node.end.column, sourceUrl, ') == null ? "" : __t);\n'),
                ];
                break;
            case 'escape':
                code = [
                    new source_map_1.SourceNode(node.start.line, node.start.column, sourceUrl, '__p += __e('),
                    ...node.expression.split('\n').map((line, i, arr) => {
                        return new source_map_1.SourceNode(node.start.line + i, i == 0 ? node.start.column : 0, sourceUrl, line + ((i == arr.length - 1) ? '' : '\n'));
                    }),
                    new source_map_1.SourceNode(node.end.line, node.end.column, sourceUrl, ');\n'),
                ];
                break;
            case 'evaluate':
                code = [
                    ...node.expression.split('\n').map((line, i, arr) => {
                        return new source_map_1.SourceNode(node.start.line + i, i == 0 ? node.start.column : 0, sourceUrl, line + ((i == arr.length - 1) ? '' : '\n'));
                    }),
                    new source_map_1.SourceNode(node.end.line, node.end.column, sourceUrl, '\n'),
                ];
                break;
        }
        return chunk.add(new source_map_1.SourceNode(node.start.line, node.start.column, sourceUrl, code));
    }, preamble)
        .add(new source_map_1.SourceNode(end.line, end.column, sourceUrl, [
        '  };\n',
        '\n',
        '  return __p;\n',
        '}\n',
    ]));
    const code = nodes.toStringWithSourceMap({
        file: sourceUrl,
        sourceRoot: options && options.sourceRoot || '.',
    });
    // Set the source content in the source map, otherwise the sourceUrl is not enough
    // to find the content.
    code.map.setSourceContent(sourceUrl, ast.content);
    return code.code
        + '\n//# sourceMappingURL=data:application/json;base64,'
        + new Buffer(code.map.toString()).toString('base64');
}
/**
 * An equivalent of EJS templates, which is based on John Resig's `tmpl` implementation
 * (http://ejohn.org/blog/javascript-micro-templating/) and Laura Doktorova's doT.js
 * (https://github.com/olado/doT).
 *
 * This version differs from lodash by removing support from ES6 quasi-literals, and making the
 * code slightly simpler to follow. It also does not depend on any third party, which is nice.
 *
 * Finally, it supports SourceMap, if you ever need to debug, which is super nice.
 *
 * @param content The template content.
 * @param options Optional Options. See TemplateOptions for more description.
 * @return {(input: T) => string} A function that accept an input object and returns the content
 *         of the template with the input applied.
 */
function template(content, options) {
    const sourceUrl = options && options.sourceURL || 'ejs';
    const ast = templateParser(content, sourceUrl);
    let source;
    // If there's no need for source map support, we revert back to the fast implementation.
    if (options && options.sourceMap) {
        source = templateWithSourceMap(ast, options);
    }
    else {
        source = templateFast(ast, options);
    }
    // We pass a dummy module in case the module option is passed. If `module: true` is passed, we
    // need to only use the source, not the function itself. Otherwise expect a module object to be
    // passed, and we use that one.
    const fn = Function('module', source);
    const module = options && options.module
        ? (options.module === true ? { exports: {} } : options.module)
        : null;
    const result = fn(module);
    // Provide the compiled function's source by its `toString` method or
    // the `source` property as a convenience for inlining compiled templates.
    result.source = source;
    return result;
}
exports.template = template;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVtcGxhdGUuanMiLCJzb3VyY2VSb290IjoiL1VzZXJzL2hhbnNsL1NvdXJjZXMvaGFuc2wvZGV2a2l0LyIsInNvdXJjZXMiOlsicGFja2FnZXMvYW5ndWxhcl9kZXZraXQvY29yZS9zcmMvdXRpbHMvdGVtcGxhdGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7Ozs7O0dBTUc7QUFDSCwyQ0FBa0Q7QUFFbEQsaUZBQWlGO0FBQ2pGLE1BQU0sY0FBYyxHQUFHLGtCQUFrQixDQUFDO0FBQzFDLG9FQUFvRTtBQUNwRSxNQUFNLFVBQVUsR0FBRyxrQkFBa0IsQ0FBQztBQUV0QyxxQ0FBcUM7QUFDckMsc0NBQXNDO0FBQ3RDLHVDQUF1QztBQUN2QyxNQUFNLFNBQVMsR0FBRyxrQkFBa0IsQ0FBQztBQUNyQyxNQUFNLFdBQVcsR0FBRyxpQkFBaUIsQ0FBQztBQUV0QywrQ0FBK0M7QUFDL0MsTUFBTSxZQUFZLEdBQTZCO0lBQzdDLEdBQUcsRUFBRSxPQUFPO0lBQ1osR0FBRyxFQUFFLE1BQU07SUFDWCxHQUFHLEVBQUUsTUFBTTtJQUNYLEdBQUcsRUFBRSxRQUFRO0lBQ2IsR0FBRyxFQUFFLE9BQU87SUFDWixHQUFHLEVBQUUsT0FBTztDQUNiLENBQUM7QUFFRixtREFBbUQ7QUFDbkQsTUFBTSxlQUFlLEdBQUcsSUFBSSxNQUFNLENBQUMsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBWW5GLHNCQUFzQixPQUFlLEVBQUUsTUFBYztJQUNuRCxJQUFJLElBQUksR0FBRyxDQUFDLENBQUM7SUFDYixJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFDZixHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztRQUNwQyxFQUFFLENBQUMsQ0FB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QUFNLE1BQU0sR0FBRyxPQUFPLElBQUksT0FBTyxDQUFDLE1BQU07UUFDM0IsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDO1FBQzlELENBQUMsQ0FBQyxJQUFJLENBQUM7SUFDcEIsTUFBTSxNQUFNLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBRTFCLHFFQUFxRTtJQUNyRSwwRUFBMEU7SUFDMUUsTUFBTSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7SUFFdkIsTUFBTSxDQUFDLE1BQU0sQ0FBQztBQUNoQixDQUFDO0FBMUJELDRCQTBCQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmltcG9ydCB7IFBvc2l0aW9uLCBTb3VyY2VOb2RlIH0gZnJvbSAnc291cmNlLW1hcCc7XG5cbi8vIE1hdGNoZXMgPCU9IGV4cHIgJT4uIFRoaXMgZG9lcyBub3Qgc3VwcG9ydCBzdHJ1Y3R1cmFsIEphdmFTY3JpcHQgKGZvci9pZi8uLi4pLlxuY29uc3Qga0ludGVycG9sYXRlUmUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcbi8vIE1hdGNoZXMgPCUjIHRleHQgJT4uIEl0J3MgYSBjb21tZW50IGFuZCB3aWxsIGJlIGVudGlyZWx5IGlnbm9yZWQuXG5jb25zdCBrQ29tbWVudFJlID0gLzwlIyhbXFxzXFxTXSs/KSU+L2c7XG5cbi8vIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy5cbi8vIDwlLSBleHByICU+OiBIVE1MIGVzY2FwZSB0aGUgdmFsdWUuXG4vLyA8JSAuLi4gJT46IFN0cnVjdHVyYWwgdGVtcGxhdGUgY29kZS5cbmNvbnN0IGtFc2NhcGVSZSA9IC88JS0oW1xcc1xcU10rPyklPi9nO1xuY29uc3Qga0V2YWx1YXRlUmUgPSAvPCUoW1xcc1xcU10rPyklPi9nO1xuXG4vKiogVXNlZCB0byBtYXAgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLiAqL1xuY29uc3Qga0h0bWxFc2NhcGVzOiB7W2NoYXI6IHN0cmluZ106IHN0cmluZ30gPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgXCInXCI6ICcmIzM5OycsXG4gICdgJzogJyYjOTY7Jyxcbn07XG5cbi8vIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzLlxuY29uc3QgcmVVbmVzY2FwZWRIdG1sID0gbmV3IFJlZ0V4cChgWyR7T2JqZWN0LmtleXMoa0h0bWxFc2NhcGVzKS5qb2luKCcnKX1dYCwgJ2cnKTtcblxuLy8gT3B0aW9ucyB0byBwYXNzIHRvIHRlbXBsYXRlLlxuZXhwb3J0IGludGVyZmFjZSBUZW1wbGF0ZU9wdGlvbnMge1xuICBzb3VyY2VVUkw/OiBzdHJpbmc7XG4gIHNvdXJjZU1hcD86IGJvb2xlYW47XG4gIG1vZHVsZT86IGJvb2xlYW4gfCB7IGV4cG9ydHM6IHt9IH07XG4gIHNvdXJjZVJvb3Q/OiBzdHJpbmc7XG4gIGZpbGVOYW1lPzogc3RyaW5nO1xufVxuXG5cbmZ1bmN0aW9uIF9wb3NpdGlvbkZvcihjb250ZW50OiBzdHJpbmcsIG9mZnNldDogbnVtYmVyKTogUG9zaXRpb24ge1xuICBsZXQgbGluZSA9IDE7XG4gIGxldCBjb2x1bW4gPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG9mZnNldCAtIDE7IGkrKykge1xuICAgIGlmIChjb250ZW50W2ldID09ICdcXG4nKSB7XG4gICAgICBsaW5lKys7XG4gICAgICBjb2x1bW4gPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2x1bW4rKztcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxpbmUsXG4gICAgY29sdW1uLFxuICB9O1xufVxuXG4vKipcbiAqIEEgc2ltcGxlIEFTVCBmb3IgdGVtcGxhdGVzLiBUaGVyZSdzIG9ubHkgb25lIGxldmVsIG9mIEFTVCBub2RlcywgYnV0IGl0J3Mgc3RpbGwgdXNlZnVsXG4gKiB0byBoYXZlIHRoZSBpbmZvcm1hdGlvbiB5b3UncmUgbG9va2luZyBmb3IuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGVtcGxhdGVBc3Qge1xuICBmaWxlTmFtZTogc3RyaW5nO1xuICBjb250ZW50OiBzdHJpbmc7XG4gIGNoaWxkcmVuOiBUZW1wbGF0ZUFzdE5vZGVbXTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSwgd2hpY2ggY29udGFpbnMgcG9zaXRpb25zLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRlbXBsYXRlQXN0QmFzZSB7XG4gIHN0YXJ0OiBQb3NpdGlvbjtcbiAgZW5kOiBQb3NpdGlvbjtcbn1cblxuLyoqXG4gKiBBIHN0YXRpYyBjb250ZW50IG5vZGUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGVtcGxhdGVBc3RDb250ZW50IGV4dGVuZHMgVGVtcGxhdGVBc3RCYXNlIHtcbiAga2luZDogJ2NvbnRlbnQnO1xuICBjb250ZW50OiBzdHJpbmc7XG59XG5cbi8qKlxuICogQSBjb21tZW50IG5vZGUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGVtcGxhdGVBc3RDb21tZW50IGV4dGVuZHMgVGVtcGxhdGVBc3RCYXNlIHtcbiAga2luZDogJ2NvbW1lbnQnO1xuICB0ZXh0OiBzdHJpbmc7XG59XG5cbi8qKlxuICogQW4gZXZhbHVhdGUgbm9kZSwgd2hpY2ggaXMgdGhlIGNvZGUgYmV0d2VlbiBgPCUgLi4uICU+YC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZW1wbGF0ZUFzdEV2YWx1YXRlIGV4dGVuZHMgVGVtcGxhdGVBc3RCYXNlIHtcbiAga2luZDogJ2V2YWx1YXRlJztcbiAgZXhwcmVzc2lvbjogc3RyaW5nO1xufVxuXG4vKipcbiAqIEFuIGVzY2FwZSBub2RlLCB3aGljaCBpcyB0aGUgY29kZSBiZXR3ZWVuIGA8JS0gLi4uICU+YC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZW1wbGF0ZUFzdEVzY2FwZSBleHRlbmRzIFRlbXBsYXRlQXN0QmFzZSB7XG4gIGtpbmQ6ICdlc2NhcGUnO1xuICBleHByZXNzaW9uOiBzdHJpbmc7XG59XG5cbi8qKlxuICogQW4gaW50ZXJwb2xhdGlvbiBub2RlLCB3aGljaCBpcyB0aGUgY29kZSBiZXR3ZWVuIGA8JT0gLi4uICU+YC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZW1wbGF0ZUFzdEludGVycG9sYXRlIGV4dGVuZHMgVGVtcGxhdGVBc3RCYXNlIHtcbiAga2luZDogJ2ludGVycG9sYXRlJztcbiAgZXhwcmVzc2lvbjogc3RyaW5nO1xufVxuXG5leHBvcnQgdHlwZSBUZW1wbGF0ZUFzdE5vZGUgPSBUZW1wbGF0ZUFzdENvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFRlbXBsYXRlQXN0RXZhbHVhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFRlbXBsYXRlQXN0Q29tbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgVGVtcGxhdGVBc3RFc2NhcGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFRlbXBsYXRlQXN0SW50ZXJwb2xhdGU7XG5cbi8qKlxuICogR2l2ZW4gYSBzb3VyY2UgdGV4dCAoYW5kIGEgZmlsZU5hbWUpLCByZXR1cm5zIGEgVGVtcGxhdGVBc3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZW1wbGF0ZVBhcnNlcihzb3VyY2VUZXh0OiBzdHJpbmcsIGZpbGVOYW1lOiBzdHJpbmcpOiBUZW1wbGF0ZUFzdCB7XG4gIGNvbnN0IGNoaWxkcmVuID0gW107XG5cbiAgLy8gQ29tcGlsZSB0aGUgcmVnZXhwIHRvIG1hdGNoIGVhY2ggZGVsaW1pdGVyLlxuICBjb25zdCByZUV4cHJlc3Npb25zID0gW2tFc2NhcGVSZSwga0NvbW1lbnRSZSwga0ludGVycG9sYXRlUmUsIGtFdmFsdWF0ZVJlXTtcbiAgY29uc3QgcmVEZWxpbWl0ZXJzID0gUmVnRXhwKHJlRXhwcmVzc2lvbnMubWFwKHggPT4geC5zb3VyY2UpLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgY29uc3QgcGFyc2VkID0gc291cmNlVGV4dC5zcGxpdChyZURlbGltaXRlcnMpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgLy8gT3B0aW1pemF0aW9uIHRoYXQgdXNlcyB0aGUgZmFjdCB0aGF0IHRoZSBlbmQgb2YgYSBub2RlIGlzIGFsd2F5cyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXh0XG4gIC8vIG5vZGUsIHNvIHdlIGtlZXAgdGhlIHBvc2l0aW9uaW5nIG9mIHRoZSBub2RlcyBpbiBtZW1vcnkuXG4gIGxldCBzdGFydCA9IF9wb3NpdGlvbkZvcihzb3VyY2VUZXh0LCBvZmZzZXQpO1xuICBsZXQgZW5kID0gbnVsbCBhcyBQb3NpdGlvbiB8IG51bGw7XG5cbiAgY29uc3QgaW5jcmVtZW50ID0gcmVFeHByZXNzaW9ucy5sZW5ndGggKyAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZC5sZW5ndGg7IGkgKz0gaW5jcmVtZW50KSB7XG4gICAgY29uc3QgW2NvbnRlbnQsIGVzY2FwZSwgY29tbWVudCwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlXSA9IHBhcnNlZC5zbGljZShpLCBpICsgaW5jcmVtZW50KTtcbiAgICBpZiAoY29udGVudCkge1xuICAgICAgZW5kID0gX3Bvc2l0aW9uRm9yKHNvdXJjZVRleHQsIG9mZnNldCArIGNvbnRlbnQubGVuZ3RoKTtcbiAgICAgIG9mZnNldCArPSBjb250ZW50Lmxlbmd0aDtcbiAgICAgIGNoaWxkcmVuLnB1c2goeyBraW5kOiAnY29udGVudCcsIGNvbnRlbnQsIHN0YXJ0LCBlbmQgfSBhcyBUZW1wbGF0ZUFzdENvbnRlbnQpO1xuICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgfVxuICAgIGlmIChlc2NhcGUpIHtcbiAgICAgIGVuZCA9IF9wb3NpdGlvbkZvcihzb3VyY2VUZXh0LCBvZmZzZXQgKyBlc2NhcGUubGVuZ3RoICsgNSk7XG4gICAgICBvZmZzZXQgKz0gZXNjYXBlLmxlbmd0aCArIDU7XG4gICAgICBjaGlsZHJlbi5wdXNoKHsga2luZDogJ2VzY2FwZScsIGV4cHJlc3Npb246IGVzY2FwZSwgc3RhcnQsIGVuZCB9IGFzIFRlbXBsYXRlQXN0RXNjYXBlKTtcbiAgICAgIHN0YXJ0ID0gZW5kO1xuICAgIH1cbiAgICBpZiAoY29tbWVudCkge1xuICAgICAgZW5kID0gX3Bvc2l0aW9uRm9yKHNvdXJjZVRleHQsIG9mZnNldCArIGNvbW1lbnQubGVuZ3RoICsgNSk7XG4gICAgICBvZmZzZXQgKz0gY29tbWVudC5sZW5ndGggKyA1O1xuICAgICAgY2hpbGRyZW4ucHVzaCh7IGtpbmQ6ICdjb21tZW50JywgdGV4dDogY29tbWVudCwgc3RhcnQsIGVuZCB9IGFzIFRlbXBsYXRlQXN0Q29tbWVudCk7XG4gICAgICBzdGFydCA9IGVuZDtcbiAgICB9XG4gICAgaWYgKGludGVycG9sYXRlKSB7XG4gICAgICBlbmQgPSBfcG9zaXRpb25Gb3Ioc291cmNlVGV4dCwgb2Zmc2V0ICsgaW50ZXJwb2xhdGUubGVuZ3RoICsgNSk7XG4gICAgICBvZmZzZXQgKz0gaW50ZXJwb2xhdGUubGVuZ3RoICsgNTtcbiAgICAgIGNoaWxkcmVuLnB1c2goe1xuICAgICAgICBraW5kOiAnaW50ZXJwb2xhdGUnLFxuICAgICAgICBleHByZXNzaW9uOiBpbnRlcnBvbGF0ZSxcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGVuZCxcbiAgICAgIH0gYXMgVGVtcGxhdGVBc3RJbnRlcnBvbGF0ZSk7XG4gICAgICBzdGFydCA9IGVuZDtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlKSB7XG4gICAgICBlbmQgPSBfcG9zaXRpb25Gb3Ioc291cmNlVGV4dCwgb2Zmc2V0ICsgZXZhbHVhdGUubGVuZ3RoICsgNSk7XG4gICAgICBvZmZzZXQgKz0gZXZhbHVhdGUubGVuZ3RoICsgNTtcbiAgICAgIGNoaWxkcmVuLnB1c2goeyBraW5kOiAnZXZhbHVhdGUnLCBleHByZXNzaW9uOiBldmFsdWF0ZSwgc3RhcnQsIGVuZCB9IGFzIFRlbXBsYXRlQXN0RXZhbHVhdGUpO1xuICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmaWxlTmFtZSxcbiAgICBjb250ZW50OiBzb3VyY2VUZXh0LFxuICAgIGNoaWxkcmVuLFxuICB9O1xufVxuXG4vKipcbiAqIEZhc3Rlc3QgaW1wbGVtZW50YXRpb24gb2YgdGhlIHRlbXBsYXRpbmcgYWxnb3JpdGhtLiBJdCBvbmx5IGFkZCBzdHJpbmdzIGFuZCBkb2VzIG5vdCBib3RoZXJcbiAqIHdpdGggc291cmNlIG1hcHMuXG4gKi9cbmZ1bmN0aW9uIHRlbXBsYXRlRmFzdChhc3Q6IFRlbXBsYXRlQXN0LCBvcHRpb25zPzogVGVtcGxhdGVPcHRpb25zKTogc3RyaW5nIHtcbiAgY29uc3QgbW9kdWxlID0gb3B0aW9ucyAmJiBvcHRpb25zLm1vZHVsZSA/ICdtb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0nIDogJyc7XG4gIGNvbnN0IHJlSHRtbEVzY2FwZSA9IHJlVW5lc2NhcGVkSHRtbC5zb3VyY2UucmVwbGFjZSgvWyddL2csICdcXFxcXFxcXFxcXFxcXCcnKTtcblxuICByZXR1cm4gYFxuICAgIHJldHVybiAke21vZHVsZX0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICBvYmogfHwgKG9iaiA9IHt9KTtcbiAgICAgIGxldCBfX3Q7XG4gICAgICBsZXQgX19wID0gJyc7XG4gICAgICBjb25zdCBfX2VzY2FwZXMgPSAke0pTT04uc3RyaW5naWZ5KGtIdG1sRXNjYXBlcyl9O1xuICAgICAgY29uc3QgX19lc2NhcGVzcmUgPSBuZXcgUmVnRXhwKCcke3JlSHRtbEVzY2FwZX0nLCAnZycpO1xuXG4gICAgICBjb25zdCBfX2UgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBzID8gcy5yZXBsYWNlKF9fZXNjYXBlc3JlLCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIF9fZXNjYXBlc1trZXldOyB9KSA6ICcnO1xuICAgICAgfTtcbiAgICAgIHdpdGggKG9iaikge1xuICAgICAgICAke2FzdC5jaGlsZHJlbi5tYXAobm9kZSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKG5vZGUua2luZCkge1xuICAgICAgICAgICAgICBjYXNlICdjb250ZW50JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYF9fcCArPSAke0pTT04uc3RyaW5naWZ5KG5vZGUuY29udGVudCl9O2A7XG4gICAgICAgICAgICAgIGNhc2UgJ2ludGVycG9sYXRlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYF9fcCArPSAoKF9fdCA9ICgke25vZGUuZXhwcmVzc2lvbn0pKSA9PSBudWxsKSA/ICcnIDogX190O2A7XG4gICAgICAgICAgICAgIGNhc2UgJ2VzY2FwZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBfX3AgKz0gX19lKCR7bm9kZS5leHByZXNzaW9ufSk7YDtcbiAgICAgICAgICAgICAgY2FzZSAnZXZhbHVhdGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmV4cHJlc3Npb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkuam9pbignXFxuJylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gX19wO1xuICAgIH07XG4gIGA7XG59XG5cbi8qKlxuICogVGVtcGxhdGluZyBhbGdvcml0aG0gd2l0aCBzb3VyY2UgbWFwIHN1cHBvcnQuIFRoZSBtYXAgaXMgb3V0cHV0dGVkIGFzIC8vIyBzb3VyY2VNYXBVcmw9Li4uXG4gKi9cbmZ1bmN0aW9uIHRlbXBsYXRlV2l0aFNvdXJjZU1hcChhc3Q6IFRlbXBsYXRlQXN0LCBvcHRpb25zPzogVGVtcGxhdGVPcHRpb25zKTogc3RyaW5nIHtcbiAgY29uc3Qgc291cmNlVXJsID0gYXN0LmZpbGVOYW1lO1xuICBjb25zdCBtb2R1bGUgPSBvcHRpb25zICYmIG9wdGlvbnMubW9kdWxlID8gJ21vZHVsZS5leHBvcnRzLmRlZmF1bHQgPScgOiAnJztcbiAgY29uc3QgcmVIdG1sRXNjYXBlID0gcmVVbmVzY2FwZWRIdG1sLnNvdXJjZS5yZXBsYWNlKC9bJ10vZywgJ1xcXFxcXFxcXFxcXFxcJycpO1xuXG4gIGNvbnN0IHByZWFtYmxlID0gKG5ldyBTb3VyY2VOb2RlKDEsIDAsIHNvdXJjZVVybCwgJycpKVxuICAgIC5hZGQobmV3IFNvdXJjZU5vZGUoMSwgMCwgc291cmNlVXJsLCBbXG4gICAgICBgcmV0dXJuICR7bW9kdWxlfSBmdW5jdGlvbihvYmopIHtcXG5gLFxuICAgICAgJyAgb2JqIHx8IChvYmogPSB7fSk7XFxuJyxcbiAgICAgICcgIGxldCBfX3Q7XFxuJyxcbiAgICAgICcgIGxldCBfX3AgPSBcIlwiO1xcbicsXG4gICAgICBgICBjb25zdCBfX2VzY2FwZXMgPSAke0pTT04uc3RyaW5naWZ5KGtIdG1sRXNjYXBlcyl9O1xcbmAsXG4gICAgICBgICBjb25zdCBfX2VzY2FwZXNyZSA9IG5ldyBSZWdFeHAoJyR7cmVIdG1sRXNjYXBlfScsICdnJyk7XFxuYCxcbiAgICAgIGBcXG5gLFxuICAgICAgYCAgY29uc3QgX19lID0gZnVuY3Rpb24ocykgeyBgLFxuICAgICAgYCAgICByZXR1cm4gcyA/IHMucmVwbGFjZShfX2VzY2FwZXNyZSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiBfX2VzY2FwZXNba2V5XTsgfSkgOiAnJztgLFxuICAgICAgYCAgfTtcXG5gLFxuICAgICAgYCAgd2l0aCAob2JqKSB7XFxuYCxcbiAgICBdKSk7XG5cbiAgY29uc3QgZW5kID0gYXN0LmNoaWxkcmVuLmxlbmd0aFxuICAgID8gYXN0LmNoaWxkcmVuW2FzdC5jaGlsZHJlbi5sZW5ndGggLSAxXS5lbmRcbiAgICA6IHsgbGluZTogMCwgY29sdW1uOiAwIH07XG4gIGNvbnN0IG5vZGVzID0gYXN0LmNoaWxkcmVuLnJlZHVjZSgoY2h1bmssIG5vZGUpID0+IHtcbiAgICBsZXQgY29kZTogc3RyaW5nIHwgU291cmNlTm9kZSB8IChTb3VyY2VOb2RlIHwgc3RyaW5nKVtdID0gJyc7XG4gICAgc3dpdGNoIChub2RlLmtpbmQpIHtcbiAgICAgIGNhc2UgJ2NvbnRlbnQnOlxuICAgICAgICBjb2RlID0gW1xuICAgICAgICAgIG5ldyBTb3VyY2VOb2RlKG5vZGUuc3RhcnQubGluZSwgbm9kZS5zdGFydC5jb2x1bW4sIHNvdXJjZVVybCwgJ19fcCA9IF9fcCcpLFxuICAgICAgICAgIC4uLm5vZGUuY29udGVudC5zcGxpdCgnXFxuJykubWFwKChsaW5lLCBpLCBhcnIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU291cmNlTm9kZShcbiAgICAgICAgICAgICAgbm9kZS5zdGFydC5saW5lICsgaSxcbiAgICAgICAgICAgICAgaSA9PSAwID8gbm9kZS5zdGFydC5jb2x1bW4gOiAwLFxuICAgICAgICAgICAgICBzb3VyY2VVcmwsXG4gICAgICAgICAgICAgICdcXG4gICAgKyAnXG4gICAgICAgICAgICAgICsgSlNPTi5zdHJpbmdpZnkobGluZSArIChpID09IGFyci5sZW5ndGggLSAxID8gJycgOiAnXFxuJykpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBuZXcgU291cmNlTm9kZShub2RlLmVuZC5saW5lLCBub2RlLmVuZC5jb2x1bW4sIHNvdXJjZVVybCwgJztcXG4nKSxcbiAgICAgICAgXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbnRlcnBvbGF0ZSc6XG4gICAgICAgIGNvZGUgPSBbXG4gICAgICAgICAgbmV3IFNvdXJjZU5vZGUobm9kZS5zdGFydC5saW5lLCBub2RlLnN0YXJ0LmNvbHVtbiwgc291cmNlVXJsLCAnX19wICs9ICgoX190ID0gJyksXG4gICAgICAgICAgLi4ubm9kZS5leHByZXNzaW9uLnNwbGl0KCdcXG4nKS5tYXAoKGxpbmUsIGksIGFycikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTb3VyY2VOb2RlKFxuICAgICAgICAgICAgICBub2RlLnN0YXJ0LmxpbmUgKyBpLFxuICAgICAgICAgICAgICBpID09IDAgPyBub2RlLnN0YXJ0LmNvbHVtbiA6IDAsXG4gICAgICAgICAgICAgIHNvdXJjZVVybCxcbiAgICAgICAgICAgICAgbGluZSArICgoaSA9PSBhcnIubGVuZ3RoIC0gMSkgPyAnJyA6ICdcXG4nKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgbmV3IFNvdXJjZU5vZGUobm9kZS5lbmQubGluZSwgbm9kZS5lbmQuY29sdW1uLCBzb3VyY2VVcmwsICcpID09IG51bGwgPyBcIlwiIDogX190KTtcXG4nKSxcbiAgICAgICAgXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdlc2NhcGUnOlxuICAgICAgICBjb2RlID0gW1xuICAgICAgICAgIG5ldyBTb3VyY2VOb2RlKG5vZGUuc3RhcnQubGluZSwgbm9kZS5zdGFydC5jb2x1bW4sIHNvdXJjZVVybCwgJ19fcCArPSBfX2UoJyksXG4gICAgICAgICAgLi4ubm9kZS5leHByZXNzaW9uLnNwbGl0KCdcXG4nKS5tYXAoKGxpbmUsIGksIGFycikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTb3VyY2VOb2RlKFxuICAgICAgICAgICAgICBub2RlLnN0YXJ0LmxpbmUgKyBpLFxuICAgICAgICAgICAgICBpID09IDAgPyBub2RlLnN0YXJ0LmNvbHVtbiA6IDAsXG4gICAgICAgICAgICAgIHNvdXJjZVVybCxcbiAgICAgICAgICAgICAgbGluZSArICgoaSA9PSBhcnIubGVuZ3RoIC0gMSkgPyAnJyA6ICdcXG4nKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgbmV3IFNvdXJjZU5vZGUobm9kZS5lbmQubGluZSwgbm9kZS5lbmQuY29sdW1uLCBzb3VyY2VVcmwsICcpO1xcbicpLFxuICAgICAgICBdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2V2YWx1YXRlJzpcbiAgICAgICAgY29kZSA9IFtcbiAgICAgICAgICAuLi5ub2RlLmV4cHJlc3Npb24uc3BsaXQoJ1xcbicpLm1hcCgobGluZSwgaSwgYXJyKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNvdXJjZU5vZGUoXG4gICAgICAgICAgICAgIG5vZGUuc3RhcnQubGluZSArIGksXG4gICAgICAgICAgICAgIGkgPT0gMCA/IG5vZGUuc3RhcnQuY29sdW1uIDogMCxcbiAgICAgICAgICAgICAgc291cmNlVXJsLFxuICAgICAgICAgICAgICBsaW5lICsgKChpID09IGFyci5sZW5ndGggLSAxKSA/ICcnIDogJ1xcbicpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBuZXcgU291cmNlTm9kZShub2RlLmVuZC5saW5lLCBub2RlLmVuZC5jb2x1bW4sIHNvdXJjZVVybCwgJ1xcbicpLFxuICAgICAgICBdO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gY2h1bmsuYWRkKG5ldyBTb3VyY2VOb2RlKG5vZGUuc3RhcnQubGluZSwgbm9kZS5zdGFydC5jb2x1bW4sIHNvdXJjZVVybCwgY29kZSkpO1xuICB9LCBwcmVhbWJsZSlcbiAgLmFkZChuZXcgU291cmNlTm9kZShlbmQubGluZSwgZW5kLmNvbHVtbiwgc291cmNlVXJsLCBbXG4gICAgJyAgfTtcXG4nLFxuICAgICdcXG4nLFxuICAgICcgIHJldHVybiBfX3A7XFxuJyxcbiAgICAnfVxcbicsXG4gIF0pKTtcblxuICBjb25zdCBjb2RlID0gbm9kZXMudG9TdHJpbmdXaXRoU291cmNlTWFwKHtcbiAgICBmaWxlOiBzb3VyY2VVcmwsXG4gICAgc291cmNlUm9vdDogb3B0aW9ucyAmJiBvcHRpb25zLnNvdXJjZVJvb3QgfHwgJy4nLFxuICB9KTtcblxuICAvLyBTZXQgdGhlIHNvdXJjZSBjb250ZW50IGluIHRoZSBzb3VyY2UgbWFwLCBvdGhlcndpc2UgdGhlIHNvdXJjZVVybCBpcyBub3QgZW5vdWdoXG4gIC8vIHRvIGZpbmQgdGhlIGNvbnRlbnQuXG4gIGNvZGUubWFwLnNldFNvdXJjZUNvbnRlbnQoc291cmNlVXJsLCBhc3QuY29udGVudCk7XG5cbiAgcmV0dXJuIGNvZGUuY29kZVxuICAgICAgICsgJ1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJ1xuICAgICAgICsgbmV3IEJ1ZmZlcihjb2RlLm1hcC50b1N0cmluZygpKS50b1N0cmluZygnYmFzZTY0Jyk7XG59XG5cblxuLyoqXG4gKiBBbiBlcXVpdmFsZW50IG9mIEVKUyB0ZW1wbGF0ZXMsIHdoaWNoIGlzIGJhc2VkIG9uIEpvaG4gUmVzaWcncyBgdG1wbGAgaW1wbGVtZW50YXRpb25cbiAqIChodHRwOi8vZWpvaG4ub3JnL2Jsb2cvamF2YXNjcmlwdC1taWNyby10ZW1wbGF0aW5nLykgYW5kIExhdXJhIERva3Rvcm92YSdzIGRvVC5qc1xuICogKGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1QpLlxuICpcbiAqIFRoaXMgdmVyc2lvbiBkaWZmZXJzIGZyb20gbG9kYXNoIGJ5IHJlbW92aW5nIHN1cHBvcnQgZnJvbSBFUzYgcXVhc2ktbGl0ZXJhbHMsIGFuZCBtYWtpbmcgdGhlXG4gKiBjb2RlIHNsaWdodGx5IHNpbXBsZXIgdG8gZm9sbG93LiBJdCBhbHNvIGRvZXMgbm90IGRlcGVuZCBvbiBhbnkgdGhpcmQgcGFydHksIHdoaWNoIGlzIG5pY2UuXG4gKlxuICogRmluYWxseSwgaXQgc3VwcG9ydHMgU291cmNlTWFwLCBpZiB5b3UgZXZlciBuZWVkIHRvIGRlYnVnLCB3aGljaCBpcyBzdXBlciBuaWNlLlxuICpcbiAqIEBwYXJhbSBjb250ZW50IFRoZSB0ZW1wbGF0ZSBjb250ZW50LlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgT3B0aW9ucy4gU2VlIFRlbXBsYXRlT3B0aW9ucyBmb3IgbW9yZSBkZXNjcmlwdGlvbi5cbiAqIEByZXR1cm4geyhpbnB1dDogVCkgPT4gc3RyaW5nfSBBIGZ1bmN0aW9uIHRoYXQgYWNjZXB0IGFuIGlucHV0IG9iamVjdCBhbmQgcmV0dXJucyB0aGUgY29udGVudFxuICogICAgICAgICBvZiB0aGUgdGVtcGxhdGUgd2l0aCB0aGUgaW5wdXQgYXBwbGllZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlPFQ+KGNvbnRlbnQ6IHN0cmluZywgb3B0aW9ucz86IFRlbXBsYXRlT3B0aW9ucyk6IChpbnB1dDogVCkgPT4gc3RyaW5nIHtcbiAgY29uc3Qgc291cmNlVXJsID0gb3B0aW9ucyAmJiBvcHRpb25zLnNvdXJjZVVSTCB8fCAnZWpzJztcbiAgY29uc3QgYXN0ID0gdGVtcGxhdGVQYXJzZXIoY29udGVudCwgc291cmNlVXJsKTtcblxuICBsZXQgc291cmNlOiBzdHJpbmc7XG4gIC8vIElmIHRoZXJlJ3Mgbm8gbmVlZCBmb3Igc291cmNlIG1hcCBzdXBwb3J0LCB3ZSByZXZlcnQgYmFjayB0byB0aGUgZmFzdCBpbXBsZW1lbnRhdGlvbi5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zb3VyY2VNYXApIHtcbiAgICBzb3VyY2UgPSB0ZW1wbGF0ZVdpdGhTb3VyY2VNYXAoYXN0LCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICBzb3VyY2UgPSB0ZW1wbGF0ZUZhc3QoYXN0LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIFdlIHBhc3MgYSBkdW1teSBtb2R1bGUgaW4gY2FzZSB0aGUgbW9kdWxlIG9wdGlvbiBpcyBwYXNzZWQuIElmIGBtb2R1bGU6IHRydWVgIGlzIHBhc3NlZCwgd2VcbiAgLy8gbmVlZCB0byBvbmx5IHVzZSB0aGUgc291cmNlLCBub3QgdGhlIGZ1bmN0aW9uIGl0c2VsZi4gT3RoZXJ3aXNlIGV4cGVjdCBhIG1vZHVsZSBvYmplY3QgdG8gYmVcbiAgLy8gcGFzc2VkLCBhbmQgd2UgdXNlIHRoYXQgb25lLlxuICBjb25zdCBmbiA9IEZ1bmN0aW9uKCdtb2R1bGUnLCBzb3VyY2UpO1xuICBjb25zdCBtb2R1bGUgPSBvcHRpb25zICYmIG9wdGlvbnMubW9kdWxlXG4gICAgICAgICAgICAgICA/IChvcHRpb25zLm1vZHVsZSA9PT0gdHJ1ZSA/IHsgZXhwb3J0czoge30gfSA6IG9wdGlvbnMubW9kdWxlKVxuICAgICAgICAgICAgICAgOiBudWxsO1xuICBjb25zdCByZXN1bHQgPSBmbihtb2R1bGUpO1xuXG4gIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uJ3Mgc291cmNlIGJ5IGl0cyBgdG9TdHJpbmdgIG1ldGhvZCBvclxuICAvLyB0aGUgYHNvdXJjZWAgcHJvcGVydHkgYXMgYSBjb252ZW5pZW5jZSBmb3IgaW5saW5pbmcgY29tcGlsZWQgdGVtcGxhdGVzLlxuICByZXN1bHQuc291cmNlID0gc291cmNlO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG4iXX0=